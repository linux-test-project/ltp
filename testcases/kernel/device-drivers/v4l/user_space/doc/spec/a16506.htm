<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Video For Linux Two Header File</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Video for Linux Two API Specification"
HREF="book1.htm"><LINK
REL="PREVIOUS"
TITLE="Obsolete API Elements"
HREF="x16497.htm"><LINK
REL="NEXT"
TITLE="Video Capture Example"
HREF="a16706.htm"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Video for Linux Two API Specification: Revision 0.24</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x16497.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="a16706.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
><A
NAME="VIDEODEV"
></A
>Appendix A. Video For Linux Two Header File</H1
><PRE
CLASS="PROGRAMLISTING"
>/*
 *  Video for Linux Two header file
 *
 *  Copyright (C) 1999-2007 the contributors
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  Alternatively you can redistribute this file under the terms of the
 *  BSD license as stated below:
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *  3. The names of its contributors may not be used to endorse or promote
 *     products derived from this software without specific prior written
 *     permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *      Header file for v4l or V4L2 drivers and applications
 * with public API.
 * All kernel-specific stuff were moved to media/v4l2-dev.h, so
 * no #if __KERNEL tests are allowed here
 *
 *      See http://linuxtv.org for more info
 *
 *      Author: Bill Dirks &lt;bill@thedirks.org&gt;
 *              Justin Schoeman
 *              Hans Verkuil &lt;hverkuil@xs4all.nl&gt;
 *              et al.
 */
#ifndef __LINUX_VIDEODEV2_H
#define __LINUX_VIDEODEV2_H
#ifdef __KERNEL__
#include &lt;linux/time.h&gt;     /* need struct timeval */
#include &lt;linux/compiler.h&gt; /* need __user */
#else
#define __user
#include &lt;sys/time.h&gt;
#endif
#include &lt;linux/ioctl.h&gt;
#include &lt;linux/types.h&gt;

/*
 * Common stuff for both V4L1 and V4L2
 * Moved from videodev.h
 */
#define VIDEO_MAX_FRAME               32

#define VID_TYPE_CAPTURE        1       /* Can capture */
#define VID_TYPE_TUNER          2       /* Can tune */
#define VID_TYPE_TELETEXT       4       /* Does teletext */
#define VID_TYPE_OVERLAY        8       /* Overlay onto frame buffer */
#define VID_TYPE_CHROMAKEY      16      /* Overlay by chromakey */
#define VID_TYPE_CLIPPING       32      /* Can clip */
#define VID_TYPE_FRAMERAM       64      /* Uses the frame buffer memory */
#define VID_TYPE_SCALES         128     /* Scalable */
#define VID_TYPE_MONOCHROME     256     /* Monochrome only */
#define VID_TYPE_SUBCAPTURE     512     /* Can capture subareas of the image */
#define VID_TYPE_MPEG_DECODER   1024    /* Can decode MPEG streams */
#define VID_TYPE_MPEG_ENCODER   2048    /* Can encode MPEG streams */
#define VID_TYPE_MJPEG_DECODER  4096    /* Can decode MJPEG streams */
#define VID_TYPE_MJPEG_ENCODER  8192    /* Can encode MJPEG streams */

/*
 *      M I S C E L L A N E O U S
 */

/*  Four-character-code (FOURCC) */
#define v4l2_fourcc(a,b,c,d)\
        (((__u32)(a)&lt;&lt;0)|((__u32)(b)&lt;&lt;8)|((__u32)(c)&lt;&lt;16)|((__u32)(d)&lt;&lt;24))

/*
 *      E N U M S
 */
enum <A
HREF="x6386.htm#V4L2-FIELD"
>v4l2_field</A
> {
        V4L2_FIELD_ANY           = 0, /* driver can choose from none,
                                         top, bottom, interlaced
                                         depending on whatever it thinks
                                         is approximate ... */
        V4L2_FIELD_NONE          = 1, /* this device has no fields ... */
        V4L2_FIELD_TOP           = 2, /* top field only */
        V4L2_FIELD_BOTTOM        = 3, /* bottom field only */
        V4L2_FIELD_INTERLACED    = 4, /* both fields interlaced */
        V4L2_FIELD_SEQ_TB        = 5, /* both fields sequential into one
                                         buffer, top-bottom order */
        V4L2_FIELD_SEQ_BT        = 6, /* same as above + bottom-top order */
        V4L2_FIELD_ALTERNATE     = 7, /* both fields alternating into
                                         separate buffers */
        V4L2_FIELD_INTERLACED_TB = 8, /* both fields interlaced, top field
                                         first and the top field is
                                         transmitted first */
        V4L2_FIELD_INTERLACED_BT = 9, /* both fields interlaced, top field
                                         first and the bottom field is
                                         transmitted first */
};
#define V4L2_FIELD_HAS_TOP(field)       \
        ((field) == V4L2_FIELD_TOP      ||\
         (field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB   ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_BOTTOM(field)    \
        ((field) == V4L2_FIELD_BOTTOM   ||\
         (field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB   ||\
         (field) == V4L2_FIELD_SEQ_BT)
#define V4L2_FIELD_HAS_BOTH(field)      \
        ((field) == V4L2_FIELD_INTERLACED ||\
         (field) == V4L2_FIELD_INTERLACED_TB ||\
         (field) == V4L2_FIELD_INTERLACED_BT ||\
         (field) == V4L2_FIELD_SEQ_TB ||\
         (field) == V4L2_FIELD_SEQ_BT)

enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
> {
        V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1,
        V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2,
        V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3,
        V4L2_BUF_TYPE_VBI_CAPTURE          = 4,
        V4L2_BUF_TYPE_VBI_OUTPUT           = 5,
        V4L2_BUF_TYPE_SLICED_VBI_CAPTURE   = 6,
        V4L2_BUF_TYPE_SLICED_VBI_OUTPUT    = 7,
#if 1 /*KEEP*/
        /* Experimental */
        V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
#endif
        V4L2_BUF_TYPE_PRIVATE              = 0x80,
};

enum <A
HREF="r13317.htm#V4L2-CTRL-TYPE"
>v4l2_ctrl_type</A
> {
        V4L2_CTRL_TYPE_INTEGER       = 1,
        V4L2_CTRL_TYPE_BOOLEAN       = 2,
        V4L2_CTRL_TYPE_MENU          = 3,
        V4L2_CTRL_TYPE_BUTTON        = 4,
        V4L2_CTRL_TYPE_INTEGER64     = 5,
        V4L2_CTRL_TYPE_CTRL_CLASS    = 6,
};

enum <A
HREF="r12342.htm#V4L2-TUNER-TYPE"
>v4l2_tuner_type</A
> {
        V4L2_TUNER_RADIO             = 1,
        V4L2_TUNER_ANALOG_TV         = 2,
        V4L2_TUNER_DIGITAL_TV        = 3,
};

enum <A
HREF="x5953.htm#V4L2-MEMORY"
>v4l2_memory</A
> {
        V4L2_MEMORY_MMAP             = 1,
        V4L2_MEMORY_USERPTR          = 2,
        V4L2_MEMORY_OVERLAY          = 3,
};

/* see also http://vektor.theorem.ca/graphics/ycbcr/ */
enum <A
HREF="x2123.htm#V4L2-COLORSPACE"
>v4l2_colorspace</A
> {
        /* ITU-R 601 -- broadcast NTSC/PAL */
        V4L2_COLORSPACE_SMPTE170M     = 1,

        /* 1125-Line (US) HDTV */
        V4L2_COLORSPACE_SMPTE240M     = 2,

        /* HD and modern captures. */
        V4L2_COLORSPACE_REC709        = 3,

        /* broken BT878 extents (601, luma range 16-253 instead of 16-235) */
        V4L2_COLORSPACE_BT878         = 4,

        /* These should be useful.  Assume 601 extents. */
        V4L2_COLORSPACE_470_SYSTEM_M  = 5,
        V4L2_COLORSPACE_470_SYSTEM_BG = 6,

        /* I know there will be cameras that send this.  So, this is
         * unspecified chromaticities and full 0-255 on each of the
         * Y'CbCr components
         */
        V4L2_COLORSPACE_JPEG          = 7,

        /* For RGB colourspaces, this is probably a good start. */
        V4L2_COLORSPACE_SRGB          = 8,
};

enum <A
HREF="r11946.htm#V4L2-PRIORITY"
>v4l2_priority</A
> {
        V4L2_PRIORITY_UNSET       = 0,  /* not initialized */
        V4L2_PRIORITY_BACKGROUND  = 1,
        V4L2_PRIORITY_INTERACTIVE = 2,
        V4L2_PRIORITY_RECORD      = 3,
        V4L2_PRIORITY_DEFAULT     = V4L2_PRIORITY_INTERACTIVE,
};

struct <A
HREF="x6570.htm#V4L2-RECT"
>v4l2_rect</A
> {
        __s32   left;
        __s32   top;
        __s32   width;
        __s32   height;
};

struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
> {
        __u32   numerator;
        __u32   denominator;
};

/*
 *      D R I V E R   C A P A B I L I T I E S
 */
struct <A
HREF="r13105.htm#V4L2-CAPABILITY"
>v4l2_capability</A
>
{
        __u8    driver[16];     /* i.e.ie; "bttv" */
        __u8    card[32];       /* i.e.ie; "Hauppauge WinTV" */
        __u8    bus_info[32];   /* "PCI:" + pci_name(pci_dev) */
        __u32   version;        /* should use KERNEL_VERSION() */
        __u32   capabilities;   /* Device capabilities */
        __u32   reserved[4];
};

/* Values for 'capabilities' field */
#define V4L2_CAP_VIDEO_CAPTURE          0x00000001  /* Is a video capture device */
#define V4L2_CAP_VIDEO_OUTPUT           0x00000002  /* Is a video output device */
#define V4L2_CAP_VIDEO_OVERLAY          0x00000004  /* Can do video overlay */
#define V4L2_CAP_VBI_CAPTURE            0x00000010  /* Is a raw VBI capture device */
#define V4L2_CAP_VBI_OUTPUT             0x00000020  /* Is a raw VBI output device */
#define V4L2_CAP_SLICED_VBI_CAPTURE     0x00000040  /* Is a sliced VBI capture device */
#define V4L2_CAP_SLICED_VBI_OUTPUT      0x00000080  /* Is a sliced VBI output device */
#define V4L2_CAP_RDS_CAPTURE            0x00000100  /* RDS data capture */
#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY   0x00000200  /* Can do video output overlay */

#define V4L2_CAP_TUNER                  0x00010000  /* has a tuner */
#define V4L2_CAP_AUDIO                  0x00020000  /* has audio support */
#define V4L2_CAP_RADIO                  0x00040000  /* is a radio device */

#define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */
#define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */
#define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */

/*
 *      V I D E O   I M A G E   F O R M A T
 */
struct <A
HREF="c2030.htm#V4L2-PIX-FORMAT"
>v4l2_pix_format</A
>
{
        __u32                   width;
        __u32                   height;
        __u32                   pixelformat;
        enum <A
HREF="x6386.htm#V4L2-FIELD"
>v4l2_field</A
>         field;
        __u32                   bytesperline;   /* for padding, zero if unused */
        __u32                   sizeimage;
        enum <A
HREF="x2123.htm#V4L2-COLORSPACE"
>v4l2_colorspace</A
>    colorspace;
        __u32                   priv;           /* private data, depends on pixelformat */
};

/*      Pixel format         FOURCC                        depth  Description  */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB332"
>V4L2_PIX_FMT_RGB332</A
>  v4l2_fourcc('R','G','B','1') /*  8  RGB-3-3-2     */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB444"
>V4L2_PIX_FMT_RGB444</A
>  v4l2_fourcc('R','4','4','4') /* 16  xxxxrrrr ggggbbbb */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB555"
>V4L2_PIX_FMT_RGB555</A
>  v4l2_fourcc('R','G','B','O') /* 16  RGB-5-5-5     */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB565"
>V4L2_PIX_FMT_RGB565</A
>  v4l2_fourcc('R','G','B','P') /* 16  RGB-5-6-5     */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB555X"
>V4L2_PIX_FMT_RGB555X</A
> v4l2_fourcc('R','G','B','Q') /* 16  RGB-5-5-5 BE  */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB565X"
>V4L2_PIX_FMT_RGB565X</A
> v4l2_fourcc('R','G','B','R') /* 16  RGB-5-6-5 BE  */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-BGR24"
>V4L2_PIX_FMT_BGR24</A
>   v4l2_fourcc('B','G','R','3') /* 24  BGR-8-8-8     */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB24"
>V4L2_PIX_FMT_RGB24</A
>   v4l2_fourcc('R','G','B','3') /* 24  RGB-8-8-8     */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-BGR32"
>V4L2_PIX_FMT_BGR32</A
>   v4l2_fourcc('B','G','R','4') /* 32  BGR-8-8-8-8   */
#define <A
HREF="r2492.htm#V4L2-PIX-FMT-RGB32"
>V4L2_PIX_FMT_RGB32</A
>   v4l2_fourcc('R','G','B','4') /* 32  RGB-8-8-8-8   */
#define <A
HREF="r4185.htm"
>V4L2_PIX_FMT_GREY</A
>    v4l2_fourcc('G','R','E','Y') /*  8  Greyscale     */
#define <A
HREF="r4246.htm"
>V4L2_PIX_FMT_Y16</A
>     v4l2_fourcc('Y','1','6',' ') /* 16  Greyscale     */
#define <A
HREF="x2428.htm#V4L2-PIX-FMT-PAL8"
>V4L2_PIX_FMT_PAL8</A
>    v4l2_fourcc('P','A','L','8') /*  8  8-bit palette */
#define <A
HREF="r5016.htm#V4L2-PIX-FMT-YVU410"
>V4L2_PIX_FMT_YVU410</A
>  v4l2_fourcc('Y','V','U','9') /*  9  YVU 4:1:0     */
#define <A
HREF="r4850.htm#V4L2-PIX-FMT-YVU420"
>V4L2_PIX_FMT_YVU420</A
>  v4l2_fourcc('Y','V','1','2') /* 12  YVU 4:2:0     */
#define <A
HREF="r4339.htm"
>V4L2_PIX_FMT_YUYV</A
>    v4l2_fourcc('Y','U','Y','V') /* 16  YUV 4:2:2     */
#define <A
HREF="r4484.htm"
>V4L2_PIX_FMT_UYVY</A
>    v4l2_fourcc('U','Y','V','Y') /* 16  YUV 4:2:2     */
#define <A
HREF="r5154.htm"
>V4L2_PIX_FMT_YUV422P</A
> v4l2_fourcc('4','2','2','P') /* 16  YVU422 planar */
#define <A
HREF="r5319.htm"
>V4L2_PIX_FMT_YUV411P</A
> v4l2_fourcc('4','1','1','P') /* 16  YVU411 planar */
#define <A
HREF="r4629.htm"
>V4L2_PIX_FMT_Y41P</A
>    v4l2_fourcc('Y','4','1','P') /* 12  YUV 4:1:1     */
#define <A
HREF="r3896.htm#V4L2-PIX-FMT-YUV444"
>V4L2_PIX_FMT_YUV444</A
>  v4l2_fourcc('Y','4','4','4') /* 16  xxxxyyyy uuuuvvvv */
#define <A
HREF="r3896.htm#V4L2-PIX-FMT-YUV555"
>V4L2_PIX_FMT_YUV555</A
>  v4l2_fourcc('Y','U','V','O') /* 16  YUV-5-5-5     */
#define <A
HREF="r3896.htm#V4L2-PIX-FMT-YUV565"
>V4L2_PIX_FMT_YUV565</A
>  v4l2_fourcc('Y','U','V','P') /* 16  YUV-5-6-5     */
#define <A
HREF="r3896.htm#V4L2-PIX-FMT-YUV32"
>V4L2_PIX_FMT_YUV32</A
>   v4l2_fourcc('Y','U','V','4') /* 32  YUV-8-8-8-8   */

/* two planes -- one Y, one Cr + Cb interleaved  */
#define <A
HREF="r5470.htm#V4L2-PIX-FMT-NV12"
>V4L2_PIX_FMT_NV12</A
>    v4l2_fourcc('N','V','1','2') /* 12  Y/CbCr 4:2:0  */
#define <A
HREF="r5470.htm#V4L2-PIX-FMT-NV21"
>V4L2_PIX_FMT_NV21</A
>    v4l2_fourcc('N','V','2','1') /* 12  Y/CrCb 4:2:0  */

/*  The following formats are not defined in the V4L2 specification */
#define <A
HREF="r5016.htm#V4L2-PIX-FMT-YUV410"
>V4L2_PIX_FMT_YUV410</A
>  v4l2_fourcc('Y','U','V','9') /*  9  YUV 4:1:0     */
#define <A
HREF="r4850.htm#V4L2-PIX-FMT-YUV420"
>V4L2_PIX_FMT_YUV420</A
>  v4l2_fourcc('Y','U','1','2') /* 12  YUV 4:2:0     */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-YYUV"
>V4L2_PIX_FMT_YYUV</A
>    v4l2_fourcc('Y','Y','U','V') /* 16  YUV 4:2:2     */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-HI240"
>V4L2_PIX_FMT_HI240</A
>   v4l2_fourcc('H','I','2','4') /*  8  8-bit color   */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-HM12"
>V4L2_PIX_FMT_HM12</A
>    v4l2_fourcc('H','M','1','2') /*  8  YUV 4:2:0 16x16 macroblocks */

/* see http://www.siliconimaging.com/RGB%20Bayer.htm */
#define <A
HREF="r3735.htm"
>V4L2_PIX_FMT_SBGGR8</A
>  v4l2_fourcc('B','A','8','1') /*  8  BGBG.. GRGR.. */
#define <A
HREF="r3796.htm"
>V4L2_PIX_FMT_SBGGR16</A
> v4l2_fourcc('B','Y','R','2') /* 16  BGBG.. GRGR.. */

/* compressed formats */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-MJPEG"
>V4L2_PIX_FMT_MJPEG</A
>    v4l2_fourcc('M','J','P','G') /* Motion-JPEG   */
#define <A
HREF="x5634.htm#V4L2-PIX-FMT-JPEG"
>V4L2_PIX_FMT_JPEG</A
>     v4l2_fourcc('J','P','E','G') /* JFIF JPEG     */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-DV"
>V4L2_PIX_FMT_DV</A
>       v4l2_fourcc('d','v','s','d') /* 1394          */
#define <A
HREF="x5634.htm#V4L2-PIX-FMT-MPEG"
>V4L2_PIX_FMT_MPEG</A
>     v4l2_fourcc('M','P','E','G') /* MPEG-1/2/4    */

/*  Vendor-specific formats   */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-WNVA"
>V4L2_PIX_FMT_WNVA</A
>     v4l2_fourcc('W','N','V','A') /* Winnov hw compress */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-SN9C10X"
>V4L2_PIX_FMT_SN9C10X</A
>  v4l2_fourcc('S','9','1','0') /* SN9C10x compression */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-PWC1"
>V4L2_PIX_FMT_PWC1</A
>     v4l2_fourcc('P','W','C','1') /* pwc older webcam */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-PWC2"
>V4L2_PIX_FMT_PWC2</A
>     v4l2_fourcc('P','W','C','2') /* pwc newer webcam */
#define <A
HREF="x5665.htm#V4L2-PIX-FMT-ET61X251"
>V4L2_PIX_FMT_ET61X251</A
> v4l2_fourcc('E','6','2','5') /* ET61X251 compression */

/*
 *      F O R M A T   E N U M E R A T I O N
 */
struct <A
HREF="r8367.htm#V4L2-FMTDESC"
>v4l2_fmtdesc</A
>
{
        __u32               index;             /* Format number      */
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
>  type;              /* buffer type        */
        __u32               flags;
        __u8                description[32];   /* Description string */
        __u32               pixelformat;       /* Format fourcc      */
        __u32               reserved[4];
};

#define V4L2_FMT_FLAG_COMPRESSED 0x0001

#if 1 /*KEEP*/
        /* Experimental Frame Size and frame rate enumeration */
/*
 *      F R A M E   S I Z E   E N U M E R A T I O N
 */
enum <A
HREF="r8494.htm#V4L2-FRMSIZETYPES"
>v4l2_frmsizetypes</A
>
{
        V4L2_FRMSIZE_TYPE_DISCRETE      = 1,
        V4L2_FRMSIZE_TYPE_CONTINUOUS    = 2,
        V4L2_FRMSIZE_TYPE_STEPWISE      = 3,
};

struct <A
HREF="r8494.htm#V4L2-FRMSIZE-DISCRETE"
>v4l2_frmsize_discrete</A
>
{
        __u32                   width;          /* Frame width [pixel] */
        __u32                   height;         /* Frame height [pixel] */
};

struct <A
HREF="r8494.htm#V4L2-FRMSIZE-STEPWISE"
>v4l2_frmsize_stepwise</A
>
{
        __u32                   min_width;      /* Minimum frame width [pixel] */
        __u32                   max_width;      /* Maximum frame width [pixel] */
        __u32                   step_width;     /* Frame width step size [pixel] */
        __u32                   min_height;     /* Minimum frame height [pixel] */
        __u32                   max_height;     /* Maximum frame height [pixel] */
        __u32                   step_height;    /* Frame height step size [pixel] */
};

struct <A
HREF="r8494.htm#V4L2-FRMSIZEENUM"
>v4l2_frmsizeenum</A
>
{
        __u32                   index;          /* Frame size number */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   type;           /* Frame size type the device supports. */

        union {                                 /* Frame size */
                struct <A
HREF="r8494.htm#V4L2-FRMSIZE-DISCRETE"
>v4l2_frmsize_discrete</A
>    discrete;
                struct <A
HREF="r8494.htm#V4L2-FRMSIZE-STEPWISE"
>v4l2_frmsize_stepwise</A
>    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};

/*
 *      F R A M E   R A T E   E N U M E R A T I O N
 */
enum <A
HREF="r8724.htm#V4L2-FRMIVALTYPES"
>v4l2_frmivaltypes</A
>
{
        V4L2_FRMIVAL_TYPE_DISCRETE      = 1,
        V4L2_FRMIVAL_TYPE_CONTINUOUS    = 2,
        V4L2_FRMIVAL_TYPE_STEPWISE      = 3,
};

struct <A
HREF="r8724.htm#V4L2-FRMIVAL-STEPWISE"
>v4l2_frmival_stepwise</A
>
{
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>       min;            /* Minimum frame interval [s] */
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>       max;            /* Maximum frame interval [s] */
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>       step;           /* Frame interval step size [s] */
};

struct <A
HREF="r8724.htm#V4L2-FRMIVALENUM"
>v4l2_frmivalenum</A
>
{
        __u32                   index;          /* Frame format index */
        __u32                   pixel_format;   /* Pixel format */
        __u32                   width;          /* Frame width */
        __u32                   height;         /* Frame height */
        __u32                   type;           /* Frame interval type the device supports. */

        union {                                 /* Frame interval */
                struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>               discrete;
                struct <A
HREF="r8724.htm#V4L2-FRMIVAL-STEPWISE"
>v4l2_frmival_stepwise</A
>    stepwise;
        };

        __u32   reserved[2];                    /* Reserved space for future use */
};
#endif

/*
 *      T I M E C O D E
 */
struct <A
HREF="x5953.htm#V4L2-TIMECODE"
>v4l2_timecode</A
>
{
        __u32   type;
        __u32   flags;
        __u8    frames;
        __u8    seconds;
        __u8    minutes;
        __u8    hours;
        __u8    userbits[4];
};

/*  Type  */
#define V4L2_TC_TYPE_24FPS              1
#define V4L2_TC_TYPE_25FPS              2
#define V4L2_TC_TYPE_30FPS              3
#define V4L2_TC_TYPE_50FPS              4
#define V4L2_TC_TYPE_60FPS              5

/*  Flags  */
#define V4L2_TC_FLAG_DROPFRAME          0x0001 /* "drop-frame" mode */
#define V4L2_TC_FLAG_COLORFRAME         0x0002
#define V4L2_TC_USERBITS_field          0x000C
#define V4L2_TC_USERBITS_USERDEFINED    0x0000
#define V4L2_TC_USERBITS_8BITCHARS      0x0008
/* The above is based on SMPTE timecodes */

struct <A
HREF="r11285.htm#V4L2-JPEGCOMPRESSION"
>v4l2_jpegcompression</A
>
{
        int quality;

        int  APPn;              /* Number of APP segment to be written,
                                 * must be 0..15 */
        int  APP_len;           /* Length of data in JPEG APPn segment */
        char APP_data[60];      /* Data in the JPEG APPn segment. */

        int  COM_len;           /* Length of data in JPEG COM segment */
        char COM_data[60];      /* Data in JPEG COM segment */

        __u32 jpeg_markers;     /* Which markers should go into the JPEG
                                 * output. Unless you exactly know what
                                 * you do, leave them untouched.
                                 * Inluding less markers will make the
                                 * resulting code smaller, but there will
                                 * be fewer aplications which can read it.
                                 * The presence of the APP and COM marker
                                 * is influenced by APP_len and COM_len
                                 * ONLY, not by this property! */

#define V4L2_JPEG_MARKER_DHT (1&lt;&lt;3)    /* Define Huffman Tables */
#define V4L2_JPEG_MARKER_DQT (1&lt;&lt;4)    /* Define Quantization Tables */
#define V4L2_JPEG_MARKER_DRI (1&lt;&lt;5)    /* Define Restart Interval */
#define V4L2_JPEG_MARKER_COM (1&lt;&lt;6)    /* Comment segment */
#define V4L2_JPEG_MARKER_APP (1&lt;&lt;7)    /* App segment, driver will
                                        * allways use APP0 */
};

/*
 *      M E M O R Y - M A P P I N G   B U F F E R S
 */
struct <A
HREF="r13696.htm#V4L2-REQUESTBUFFERS"
>v4l2_requestbuffers</A
>
{
        __u32                   count;
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
>      type;
        enum <A
HREF="x5953.htm#V4L2-MEMORY"
>v4l2_memory</A
>        memory;
        __u32                   reserved[2];
};

struct <A
HREF="x5953.htm#V4L2-BUFFER"
>v4l2_buffer</A
>
{
        __u32                   index;
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
>      type;
        __u32                   bytesused;
        __u32                   flags;
        enum <A
HREF="x6386.htm#V4L2-FIELD"
>v4l2_field</A
>         field;
        struct timeval          timestamp;
        struct <A
HREF="x5953.htm#V4L2-TIMECODE"
>v4l2_timecode</A
>    timecode;
        __u32                   sequence;

        /* memory location */
        enum <A
HREF="x5953.htm#V4L2-MEMORY"
>v4l2_memory</A
>        memory;
        union {
                __u32           offset;
                unsigned long   userptr;
        } m;
        __u32                   length;
        __u32                   input;
        __u32                   reserved;
};

/*  Flags for 'flags' field */
#define V4L2_BUF_FLAG_MAPPED    0x0001  /* Buffer is mapped (flag) */
#define V4L2_BUF_FLAG_QUEUED    0x0002  /* Buffer is queued for processing */
#define V4L2_BUF_FLAG_DONE      0x0004  /* Buffer is ready */
#define V4L2_BUF_FLAG_KEYFRAME  0x0008  /* Image is a keyframe (I-frame) */
#define V4L2_BUF_FLAG_PFRAME    0x0010  /* Image is a P-frame */
#define V4L2_BUF_FLAG_BFRAME    0x0020  /* Image is a B-frame */
#define V4L2_BUF_FLAG_TIMECODE  0x0100  /* timecode field is valid */
#define V4L2_BUF_FLAG_INPUT     0x0200  /* input field is valid */

/*
 *      O V E R L A Y   P R E V I E W
 */
struct <A
HREF="r10595.htm#V4L2-FRAMEBUFFER"
>v4l2_framebuffer</A
>
{
        __u32                   capability;
        __u32                   flags;
/* FIXME: in theory we should pass something like PCI device + memory
 * region + offset instead of some physical address */
        void*                   base;
        struct <A
HREF="c2030.htm#V4L2-PIX-FORMAT"
>v4l2_pix_format</A
>  fmt;
};
/*  Flags for the 'capability' field. Read only */
#define V4L2_FBUF_CAP_EXTERNOVERLAY     0x0001
#define V4L2_FBUF_CAP_CHROMAKEY         0x0002
#define V4L2_FBUF_CAP_LIST_CLIPPING     0x0004
#define V4L2_FBUF_CAP_BITMAP_CLIPPING   0x0008
#define V4L2_FBUF_CAP_LOCAL_ALPHA       0x0010
#define V4L2_FBUF_CAP_GLOBAL_ALPHA      0x0020
#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA   0x0040
/*  Flags for the 'flags' field. */
#define V4L2_FBUF_FLAG_PRIMARY          0x0001
#define V4L2_FBUF_FLAG_OVERLAY          0x0002
#define V4L2_FBUF_FLAG_CHROMAKEY        0x0004
#define V4L2_FBUF_FLAG_LOCAL_ALPHA      0x0008
#define V4L2_FBUF_FLAG_GLOBAL_ALPHA     0x0010
#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA  0x0020

struct <A
HREF="x6570.htm#V4L2-CLIP"
>v4l2_clip</A
>
{
        struct <A
HREF="x6570.htm#V4L2-RECT"
>v4l2_rect</A
>        c;
        struct <A
HREF="x6570.htm#V4L2-CLIP"
>v4l2_clip</A
>        __user *next;
};

struct <A
HREF="x6570.htm#V4L2-WINDOW"
>v4l2_window</A
>
{
        struct <A
HREF="x6570.htm#V4L2-RECT"
>v4l2_rect</A
>        w;
        enum <A
HREF="x6386.htm#V4L2-FIELD"
>v4l2_field</A
>         field;
        __u32                   chromakey;
        struct <A
HREF="x6570.htm#V4L2-CLIP"
>v4l2_clip</A
>        __user *clips;
        __u32                   clipcount;
        void                    __user *bitmap;
        __u8                    global_alpha;
};

/*
 *      C A P T U R E   P A R A M E T E R S
 */
struct <A
HREF="r11680.htm#V4L2-CAPTUREPARM"
>v4l2_captureparm</A
>
{
        __u32              capability;    /*  Supported modes */
        __u32              capturemode;   /*  Current mode */
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>  timeperframe;  /*  Time per frame in .1us units */
        __u32              extendedmode;  /*  Driver-specific extensions */
        __u32              readbuffers;   /*  # of buffers for read */
        __u32              reserved[4];
};

/*  Flags for 'capability' and 'capturemode' fields */
#define V4L2_MODE_HIGHQUALITY   0x0001  /*  High quality imaging mode */
#define V4L2_CAP_TIMEPERFRAME   0x1000  /*  timeperframe field is supported */

struct <A
HREF="r11680.htm#V4L2-OUTPUTPARM"
>v4l2_outputparm</A
>
{
        __u32              capability;   /*  Supported modes */
        __u32              outputmode;   /*  Current mode */
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>  timeperframe; /*  Time per frame in seconds */
        __u32              extendedmode; /*  Driver-specific extensions */
        __u32              writebuffers; /*  # of buffers for write */
        __u32              reserved[4];
};

/*
 *      I N P U T   I M A G E   C R O P P I N G
 */
struct <A
HREF="r7771.htm#V4L2-CROPCAP"
>v4l2_cropcap</A
> {
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
>      type;
        struct <A
HREF="x6570.htm#V4L2-RECT"
>v4l2_rect</A
>        bounds;
        struct <A
HREF="x6570.htm#V4L2-RECT"
>v4l2_rect</A
>        defrect;
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>       pixelaspect;
};

struct <A
HREF="r9994.htm#V4L2-CROP"
>v4l2_crop</A
> {
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
>      type;
        struct <A
HREF="x6570.htm#V4L2-RECT"
>v4l2_rect</A
>        c;
};

/*
 *      A N A L O G   V I D E O   S T A N D A R D
 */

typedef __u64 v4l2_std_id;

/* one bit for each */
#define V4L2_STD_PAL_B          ((v4l2_std_id)0x00000001)
#define V4L2_STD_PAL_B1         ((v4l2_std_id)0x00000002)
#define V4L2_STD_PAL_G          ((v4l2_std_id)0x00000004)
#define V4L2_STD_PAL_H          ((v4l2_std_id)0x00000008)
#define V4L2_STD_PAL_I          ((v4l2_std_id)0x00000010)
#define V4L2_STD_PAL_D          ((v4l2_std_id)0x00000020)
#define V4L2_STD_PAL_D1         ((v4l2_std_id)0x00000040)
#define V4L2_STD_PAL_K          ((v4l2_std_id)0x00000080)

#define V4L2_STD_PAL_M          ((v4l2_std_id)0x00000100)
#define V4L2_STD_PAL_N          ((v4l2_std_id)0x00000200)
#define V4L2_STD_PAL_Nc         ((v4l2_std_id)0x00000400)
#define V4L2_STD_PAL_60         ((v4l2_std_id)0x00000800)

#define V4L2_STD_NTSC_M         ((v4l2_std_id)0x00001000)
#define V4L2_STD_NTSC_M_JP      ((v4l2_std_id)0x00002000)
#define V4L2_STD_NTSC_443       ((v4l2_std_id)0x00004000)
#define V4L2_STD_NTSC_M_KR      ((v4l2_std_id)0x00008000)

#define V4L2_STD_SECAM_B        ((v4l2_std_id)0x00010000)
#define V4L2_STD_SECAM_D        ((v4l2_std_id)0x00020000)
#define V4L2_STD_SECAM_G        ((v4l2_std_id)0x00040000)
#define V4L2_STD_SECAM_H        ((v4l2_std_id)0x00080000)
#define V4L2_STD_SECAM_K        ((v4l2_std_id)0x00100000)
#define V4L2_STD_SECAM_K1       ((v4l2_std_id)0x00200000)
#define V4L2_STD_SECAM_L        ((v4l2_std_id)0x00400000)
#define V4L2_STD_SECAM_LC       ((v4l2_std_id)0x00800000)

/* ATSC/HDTV */
#define V4L2_STD_ATSC_8_VSB     ((v4l2_std_id)0x01000000)
#define V4L2_STD_ATSC_16_VSB    ((v4l2_std_id)0x02000000)

/* FIXME:
   Although std_id is 64 bits, there is an issue on PPC32 architecture that
   makes switch(__u64) to break. So, there's a hack on v4l2-common.c rounding
   this value to 32 bits.
   As, currently, the max value is for V4L2_STD_ATSC_16_VSB (30 bits wide),
   it should work fine. However, if needed to add more than two standards,
   v4l2-common.c should be fixed.
 */

/* some merged standards */
#define V4L2_STD_MN     (V4L2_STD_PAL_M|V4L2_STD_PAL_N|V4L2_STD_PAL_Nc|V4L2_STD_NTSC)
#define V4L2_STD_B      (V4L2_STD_PAL_B|V4L2_STD_PAL_B1|V4L2_STD_SECAM_B)
#define V4L2_STD_GH     (V4L2_STD_PAL_G|V4L2_STD_PAL_H|V4L2_STD_SECAM_G|V4L2_STD_SECAM_H)
#define V4L2_STD_DK     (V4L2_STD_PAL_DK|V4L2_STD_SECAM_DK)

/* some common needed stuff */
#define V4L2_STD_PAL_BG         (V4L2_STD_PAL_B         |\
                                 V4L2_STD_PAL_B1        |\
                                 V4L2_STD_PAL_G)
#define V4L2_STD_PAL_DK         (V4L2_STD_PAL_D         |\
                                 V4L2_STD_PAL_D1        |\
                                 V4L2_STD_PAL_K)
#define V4L2_STD_PAL            (V4L2_STD_PAL_BG        |\
                                 V4L2_STD_PAL_DK        |\
                                 V4L2_STD_PAL_H         |\
                                 V4L2_STD_PAL_I)
#define V4L2_STD_NTSC           (V4L2_STD_NTSC_M        |\
                                 V4L2_STD_NTSC_M_JP     |\
                                 V4L2_STD_NTSC_M_KR)
#define V4L2_STD_SECAM_DK       (V4L2_STD_SECAM_D       |\
                                 V4L2_STD_SECAM_K       |\
                                 V4L2_STD_SECAM_K1)
#define V4L2_STD_SECAM          (V4L2_STD_SECAM_B       |\
                                 V4L2_STD_SECAM_G       |\
                                 V4L2_STD_SECAM_H       |\
                                 V4L2_STD_SECAM_DK      |\
                                 V4L2_STD_SECAM_L       |\
                                 V4L2_STD_SECAM_LC)

#define V4L2_STD_525_60         (V4L2_STD_PAL_M         |\
                                 V4L2_STD_PAL_60        |\
                                 V4L2_STD_NTSC          |\
                                 V4L2_STD_NTSC_443)
#define V4L2_STD_625_50         (V4L2_STD_PAL           |\
                                 V4L2_STD_PAL_N         |\
                                 V4L2_STD_PAL_Nc        |\
                                 V4L2_STD_SECAM)
#define V4L2_STD_ATSC           (V4L2_STD_ATSC_8_VSB    |\
                                 V4L2_STD_ATSC_16_VSB)

#define V4L2_STD_UNKNOWN        0
#define V4L2_STD_ALL            (V4L2_STD_525_60        |\
                                 V4L2_STD_625_50)

struct <A
HREF="r9288.htm#V4L2-STANDARD"
>v4l2_standard</A
>
{
        __u32                index;
        v4l2_std_id          id;
        __u8                 name[24];
        struct <A
HREF="r9288.htm#V4L2-FRACT"
>v4l2_fract</A
>    frameperiod; /* Frames, not fields */
        __u32                framelines;
        __u32                reserved[4];
};

/*
 *      V I D E O   I N P U T S
 */
struct <A
HREF="r8936.htm#V4L2-INPUT"
>v4l2_input</A
>
{
        __u32        index;             /*  Which input */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of input */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        tuner;             /*  Associated tuner */
        v4l2_std_id  std;
        __u32        status;
        __u32        reserved[4];
};

/*  Values for the 'type' field */
#define V4L2_INPUT_TYPE_TUNER           1
#define V4L2_INPUT_TYPE_CAMERA          2

/* field 'status' - general */
#define V4L2_IN_ST_NO_POWER    0x00000001  /* Attached device is off */
#define V4L2_IN_ST_NO_SIGNAL   0x00000002
#define V4L2_IN_ST_NO_COLOR    0x00000004

/* field 'status' - analog */
#define V4L2_IN_ST_NO_H_LOCK   0x00000100  /* No horizontal sync lock */
#define V4L2_IN_ST_COLOR_KILL  0x00000200  /* Color killer is active */

/* field 'status' - digital */
#define V4L2_IN_ST_NO_SYNC     0x00010000  /* No synchronization lock */
#define V4L2_IN_ST_NO_EQU      0x00020000  /* No equalizer lock */
#define V4L2_IN_ST_NO_CARRIER  0x00040000  /* Carrier recovery failed */

/* field 'status' - VCR and set-top box */
#define V4L2_IN_ST_MACROVISION 0x01000000  /* Macrovision detected */
#define V4L2_IN_ST_NO_ACCESS   0x02000000  /* Conditional access denied */
#define V4L2_IN_ST_VTR         0x04000000  /* VTR time constant */

/*
 *      V I D E O   O U T P U T S
 */
struct <A
HREF="r9149.htm#V4L2-OUTPUT"
>v4l2_output</A
>
{
        __u32        index;             /*  Which output */
        __u8         name[32];          /*  Label */
        __u32        type;              /*  Type of output */
        __u32        audioset;          /*  Associated audios (bitfield) */
        __u32        modulator;         /*  Associated modulator */
        v4l2_std_id  std;
        __u32        reserved[4];
};
/*  Values for the 'type' field */
#define V4L2_OUTPUT_TYPE_MODULATOR              1
#define V4L2_OUTPUT_TYPE_ANALOG                 2
#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY       3

/*
 *      C O N T R O L S
 */
struct <A
HREF="r10104.htm#V4L2-CONTROL"
>v4l2_control</A
>
{
        __u32                id;
        __s32                value;
};

struct <A
HREF="r10386.htm#V4L2-EXT-CONTROL"
>v4l2_ext_control</A
>
{
        __u32 id;
        __u32 reserved2[2];
        union {
                __s32 value;
                __s64 value64;
                void *reserved;
        };
} __attribute__ ((packed));

struct <A
HREF="r10386.htm#V4L2-EXT-CONTROLS"
>v4l2_ext_controls</A
>
{
        __u32 ctrl_class;
        __u32 count;
        __u32 error_idx;
        __u32 reserved[2];
        struct <A
HREF="r10386.htm#V4L2-EXT-CONTROL"
>v4l2_ext_control</A
> *controls;
};

/*  Values for ctrl_class field */
#define V4L2_CTRL_CLASS_USER 0x00980000 /* Old-style 'user' controls */
#define V4L2_CTRL_CLASS_MPEG 0x00990000 /* MPEG-compression controls */
#define V4L2_CTRL_CLASS_CAMERA 0x009a0000       /* Camera class controls */

#define V4L2_CTRL_ID_MASK         (0x0fffffff)
#define V4L2_CTRL_ID2CLASS(id)    ((id) &amp; 0x0fff0000UL)
#define V4L2_CTRL_DRIVER_PRIV(id) (((id) &amp; 0xffff) &gt;= 0x1000)

/*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
struct <A
HREF="r13317.htm#V4L2-QUERYCTRL"
>v4l2_queryctrl</A
>
{
        __u32                id;
        enum <A
HREF="r13317.htm#V4L2-CTRL-TYPE"
>v4l2_ctrl_type</A
>  type;
        __u8                 name[32];  /* Whatever */
        __s32                minimum;   /* Note signedness */
        __s32                maximum;
        __s32                step;
        __s32                default_value;
        __u32                flags;
        __u32                reserved[2];
};

/*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */
struct <A
HREF="r13317.htm#V4L2-QUERYMENU"
>v4l2_querymenu</A
>
{
        __u32           id;
        __u32           index;
        __u8            name[32];       /* Whatever */
        __u32           reserved;
};

/*  Control flags  */
#define V4L2_CTRL_FLAG_DISABLED         0x0001
#define V4L2_CTRL_FLAG_GRABBED          0x0002
#define V4L2_CTRL_FLAG_READ_ONLY        0x0004
#define V4L2_CTRL_FLAG_UPDATE           0x0008
#define V4L2_CTRL_FLAG_INACTIVE         0x0010
#define V4L2_CTRL_FLAG_SLIDER           0x0020

/*  Query flag, to be ORed with the control ID */
#define V4L2_CTRL_FLAG_NEXT_CTRL        0x80000000

/*  User-class control IDs defined by V4L2 */
#define V4L2_CID_BASE                   (V4L2_CTRL_CLASS_USER | 0x900)
#define V4L2_CID_USER_BASE              V4L2_CID_BASE
/*  IDs reserved for driver specific controls */
#define V4L2_CID_PRIVATE_BASE           0x08000000

#define V4L2_CID_USER_CLASS             (V4L2_CTRL_CLASS_USER | 1)
#define V4L2_CID_BRIGHTNESS             (V4L2_CID_BASE+0)
#define V4L2_CID_CONTRAST               (V4L2_CID_BASE+1)
#define V4L2_CID_SATURATION             (V4L2_CID_BASE+2)
#define V4L2_CID_HUE                    (V4L2_CID_BASE+3)
#define V4L2_CID_AUDIO_VOLUME           (V4L2_CID_BASE+5)
#define V4L2_CID_AUDIO_BALANCE          (V4L2_CID_BASE+6)
#define V4L2_CID_AUDIO_BASS             (V4L2_CID_BASE+7)
#define V4L2_CID_AUDIO_TREBLE           (V4L2_CID_BASE+8)
#define V4L2_CID_AUDIO_MUTE             (V4L2_CID_BASE+9)
#define V4L2_CID_AUDIO_LOUDNESS         (V4L2_CID_BASE+10)
#define V4L2_CID_BLACK_LEVEL            (V4L2_CID_BASE+11) /* Deprecated */
#define V4L2_CID_AUTO_WHITE_BALANCE     (V4L2_CID_BASE+12)
#define V4L2_CID_DO_WHITE_BALANCE       (V4L2_CID_BASE+13)
#define V4L2_CID_RED_BALANCE            (V4L2_CID_BASE+14)
#define V4L2_CID_BLUE_BALANCE           (V4L2_CID_BASE+15)
#define V4L2_CID_GAMMA                  (V4L2_CID_BASE+16)
#define V4L2_CID_WHITENESS              (V4L2_CID_GAMMA) /* Deprecated */
#define V4L2_CID_EXPOSURE               (V4L2_CID_BASE+17)
#define V4L2_CID_AUTOGAIN               (V4L2_CID_BASE+18)
#define V4L2_CID_GAIN                   (V4L2_CID_BASE+19)
#define V4L2_CID_HFLIP                  (V4L2_CID_BASE+20)
#define V4L2_CID_VFLIP                  (V4L2_CID_BASE+21)

/* Deprecated, use V4L2_CID_PAN_RESET and V4L2_CID_TILT_RESET */
#define V4L2_CID_HCENTER_DEPRECATED     (V4L2_CID_BASE+22)
#define V4L2_CID_VCENTER_DEPRECATED     (V4L2_CID_BASE+23)

#define V4L2_CID_POWER_LINE_FREQUENCY   (V4L2_CID_BASE+24)
enum&nbsp;v4l2_power_line_frequency {
        V4L2_CID_POWER_LINE_FREQUENCY_DISABLED  = 0,
        V4L2_CID_POWER_LINE_FREQUENCY_50HZ      = 1,
        V4L2_CID_POWER_LINE_FREQUENCY_60HZ      = 2,
};
#define V4L2_CID_HUE_AUTO                       (V4L2_CID_BASE+25)
#define V4L2_CID_WHITE_BALANCE_TEMPERATURE      (V4L2_CID_BASE+26)
#define V4L2_CID_SHARPNESS                      (V4L2_CID_BASE+27)
#define V4L2_CID_BACKLIGHT_COMPENSATION         (V4L2_CID_BASE+28)
#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+29) /* last CID + 1 */

/*  MPEG-class control IDs defined by V4L2 */
#define V4L2_CID_MPEG_BASE                      (V4L2_CTRL_CLASS_MPEG | 0x900)
#define V4L2_CID_MPEG_CLASS                     (V4L2_CTRL_CLASS_MPEG | 1)

/*  MPEG streams */
#define V4L2_CID_MPEG_STREAM_TYPE               (V4L2_CID_MPEG_BASE+0)
enum&nbsp;v4l2_mpeg_stream_type {
        V4L2_MPEG_STREAM_TYPE_MPEG2_PS   = 0, /* MPEG-2 program stream */
        V4L2_MPEG_STREAM_TYPE_MPEG2_TS   = 1, /* MPEG-2 transport stream */
        V4L2_MPEG_STREAM_TYPE_MPEG1_SS   = 2, /* MPEG-1 system stream */
        V4L2_MPEG_STREAM_TYPE_MPEG2_DVD  = 3, /* MPEG-2 DVD-compatible stream */
        V4L2_MPEG_STREAM_TYPE_MPEG1_VCD  = 4, /* MPEG-1 VCD-compatible stream */
        V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD = 5, /* MPEG-2 SVCD-compatible stream */
};
#define V4L2_CID_MPEG_STREAM_PID_PMT            (V4L2_CID_MPEG_BASE+1)
#define V4L2_CID_MPEG_STREAM_PID_AUDIO          (V4L2_CID_MPEG_BASE+2)
#define V4L2_CID_MPEG_STREAM_PID_VIDEO          (V4L2_CID_MPEG_BASE+3)
#define V4L2_CID_MPEG_STREAM_PID_PCR            (V4L2_CID_MPEG_BASE+4)
#define V4L2_CID_MPEG_STREAM_PES_ID_AUDIO       (V4L2_CID_MPEG_BASE+5)
#define V4L2_CID_MPEG_STREAM_PES_ID_VIDEO       (V4L2_CID_MPEG_BASE+6)
#define V4L2_CID_MPEG_STREAM_VBI_FMT            (V4L2_CID_MPEG_BASE+7)
enum&nbsp;v4l2_mpeg_stream_vbi_fmt {
        V4L2_MPEG_STREAM_VBI_FMT_NONE = 0,  /* No VBI in the MPEG stream */
        V4L2_MPEG_STREAM_VBI_FMT_IVTV = 1,  /* VBI in private packets, IVTV format */
};

/*  MPEG audio */
#define V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ       (V4L2_CID_MPEG_BASE+100)
enum&nbsp;v4l2_mpeg_audio_sampling_freq {
        V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100 = 0,
        V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000 = 1,
        V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000 = 2,
};
#define V4L2_CID_MPEG_AUDIO_ENCODING            (V4L2_CID_MPEG_BASE+101)
enum&nbsp;v4l2_mpeg_audio_encoding {
        V4L2_MPEG_AUDIO_ENCODING_LAYER_1 = 0,
        V4L2_MPEG_AUDIO_ENCODING_LAYER_2 = 1,
        V4L2_MPEG_AUDIO_ENCODING_LAYER_3 = 2,
};
#define V4L2_CID_MPEG_AUDIO_L1_BITRATE          (V4L2_CID_MPEG_BASE+102)
enum&nbsp;v4l2_mpeg_audio_l1_bitrate {
        V4L2_MPEG_AUDIO_L1_BITRATE_32K  = 0,
        V4L2_MPEG_AUDIO_L1_BITRATE_64K  = 1,
        V4L2_MPEG_AUDIO_L1_BITRATE_96K  = 2,
        V4L2_MPEG_AUDIO_L1_BITRATE_128K = 3,
        V4L2_MPEG_AUDIO_L1_BITRATE_160K = 4,
        V4L2_MPEG_AUDIO_L1_BITRATE_192K = 5,
        V4L2_MPEG_AUDIO_L1_BITRATE_224K = 6,
        V4L2_MPEG_AUDIO_L1_BITRATE_256K = 7,
        V4L2_MPEG_AUDIO_L1_BITRATE_288K = 8,
        V4L2_MPEG_AUDIO_L1_BITRATE_320K = 9,
        V4L2_MPEG_AUDIO_L1_BITRATE_352K = 10,
        V4L2_MPEG_AUDIO_L1_BITRATE_384K = 11,
        V4L2_MPEG_AUDIO_L1_BITRATE_416K = 12,
        V4L2_MPEG_AUDIO_L1_BITRATE_448K = 13,
};
#define V4L2_CID_MPEG_AUDIO_L2_BITRATE          (V4L2_CID_MPEG_BASE+103)
enum&nbsp;v4l2_mpeg_audio_l2_bitrate {
        V4L2_MPEG_AUDIO_L2_BITRATE_32K  = 0,
        V4L2_MPEG_AUDIO_L2_BITRATE_48K  = 1,
        V4L2_MPEG_AUDIO_L2_BITRATE_56K  = 2,
        V4L2_MPEG_AUDIO_L2_BITRATE_64K  = 3,
        V4L2_MPEG_AUDIO_L2_BITRATE_80K  = 4,
        V4L2_MPEG_AUDIO_L2_BITRATE_96K  = 5,
        V4L2_MPEG_AUDIO_L2_BITRATE_112K = 6,
        V4L2_MPEG_AUDIO_L2_BITRATE_128K = 7,
        V4L2_MPEG_AUDIO_L2_BITRATE_160K = 8,
        V4L2_MPEG_AUDIO_L2_BITRATE_192K = 9,
        V4L2_MPEG_AUDIO_L2_BITRATE_224K = 10,
        V4L2_MPEG_AUDIO_L2_BITRATE_256K = 11,
        V4L2_MPEG_AUDIO_L2_BITRATE_320K = 12,
        V4L2_MPEG_AUDIO_L2_BITRATE_384K = 13,
};
#define V4L2_CID_MPEG_AUDIO_L3_BITRATE          (V4L2_CID_MPEG_BASE+104)
enum&nbsp;v4l2_mpeg_audio_l3_bitrate {
        V4L2_MPEG_AUDIO_L3_BITRATE_32K  = 0,
        V4L2_MPEG_AUDIO_L3_BITRATE_40K  = 1,
        V4L2_MPEG_AUDIO_L3_BITRATE_48K  = 2,
        V4L2_MPEG_AUDIO_L3_BITRATE_56K  = 3,
        V4L2_MPEG_AUDIO_L3_BITRATE_64K  = 4,
        V4L2_MPEG_AUDIO_L3_BITRATE_80K  = 5,
        V4L2_MPEG_AUDIO_L3_BITRATE_96K  = 6,
        V4L2_MPEG_AUDIO_L3_BITRATE_112K = 7,
        V4L2_MPEG_AUDIO_L3_BITRATE_128K = 8,
        V4L2_MPEG_AUDIO_L3_BITRATE_160K = 9,
        V4L2_MPEG_AUDIO_L3_BITRATE_192K = 10,
        V4L2_MPEG_AUDIO_L3_BITRATE_224K = 11,
        V4L2_MPEG_AUDIO_L3_BITRATE_256K = 12,
        V4L2_MPEG_AUDIO_L3_BITRATE_320K = 13,
};
#define V4L2_CID_MPEG_AUDIO_MODE                (V4L2_CID_MPEG_BASE+105)
enum&nbsp;v4l2_mpeg_audio_mode {
        V4L2_MPEG_AUDIO_MODE_STEREO       = 0,
        V4L2_MPEG_AUDIO_MODE_JOINT_STEREO = 1,
        V4L2_MPEG_AUDIO_MODE_DUAL         = 2,
        V4L2_MPEG_AUDIO_MODE_MONO         = 3,
};
#define V4L2_CID_MPEG_AUDIO_MODE_EXTENSION      (V4L2_CID_MPEG_BASE+106)
enum&nbsp;&nbsp;v4l2_mpeg_audio_mode_extension {
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4  = 0,
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8  = 1,
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12 = 2,
        V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16 = 3,
};
#define V4L2_CID_MPEG_AUDIO_EMPHASIS            (V4L2_CID_MPEG_BASE+107)
enum&nbsp;v4l2_mpeg_audio_emphasis {
        V4L2_MPEG_AUDIO_EMPHASIS_NONE         = 0,
        V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS = 1,
        V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17    = 2,
};
#define V4L2_CID_MPEG_AUDIO_CRC                 (V4L2_CID_MPEG_BASE+108)
enum&nbsp;v4l2_mpeg_audio_crc {
        V4L2_MPEG_AUDIO_CRC_NONE  = 0,
        V4L2_MPEG_AUDIO_CRC_CRC16 = 1,
};
#define V4L2_CID_MPEG_AUDIO_MUTE                (V4L2_CID_MPEG_BASE+109)

/*  MPEG video */
#define V4L2_CID_MPEG_VIDEO_ENCODING            (V4L2_CID_MPEG_BASE+200)
enum&nbsp;v4l2_mpeg_video_encoding {
        V4L2_MPEG_VIDEO_ENCODING_MPEG_1 = 0,
        V4L2_MPEG_VIDEO_ENCODING_MPEG_2 = 1,
};
#define V4L2_CID_MPEG_VIDEO_ASPECT              (V4L2_CID_MPEG_BASE+201)
enum&nbsp;v4l2_mpeg_video_aspect {
        V4L2_MPEG_VIDEO_ASPECT_1x1     = 0,
        V4L2_MPEG_VIDEO_ASPECT_4x3     = 1,
        V4L2_MPEG_VIDEO_ASPECT_16x9    = 2,
        V4L2_MPEG_VIDEO_ASPECT_221x100 = 3,
};
#define V4L2_CID_MPEG_VIDEO_B_FRAMES            (V4L2_CID_MPEG_BASE+202)
#define V4L2_CID_MPEG_VIDEO_GOP_SIZE            (V4L2_CID_MPEG_BASE+203)
#define V4L2_CID_MPEG_VIDEO_GOP_CLOSURE         (V4L2_CID_MPEG_BASE+204)
#define V4L2_CID_MPEG_VIDEO_PULLDOWN            (V4L2_CID_MPEG_BASE+205)
#define V4L2_CID_MPEG_VIDEO_BITRATE_MODE        (V4L2_CID_MPEG_BASE+206)
enum&nbsp;v4l2_mpeg_video_bitrate_mode {
        V4L2_MPEG_VIDEO_BITRATE_MODE_VBR = 0,
        V4L2_MPEG_VIDEO_BITRATE_MODE_CBR = 1,
};
#define V4L2_CID_MPEG_VIDEO_BITRATE             (V4L2_CID_MPEG_BASE+207)
#define V4L2_CID_MPEG_VIDEO_BITRATE_PEAK        (V4L2_CID_MPEG_BASE+208)
#define V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION (V4L2_CID_MPEG_BASE+209)
#define V4L2_CID_MPEG_VIDEO_MUTE                (V4L2_CID_MPEG_BASE+210)
#define V4L2_CID_MPEG_VIDEO_MUTE_YUV            (V4L2_CID_MPEG_BASE+211)

/*  MPEG-class control IDs specific to the CX2584x driver as defined by V4L2 */
#define V4L2_CID_MPEG_CX2341X_BASE                              (V4L2_CTRL_CLASS_MPEG | 0x1000)
#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE         (V4L2_CID_MPEG_CX2341X_BASE+0)
enum&nbsp;v4l2_mpeg_cx2341x_video_spatial_filter_mode {
        V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL = 0,
        V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO   = 1,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER              (V4L2_CID_MPEG_CX2341X_BASE+1)
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE    (V4L2_CID_MPEG_CX2341X_BASE+2)
enum&nbsp;v4l2_mpeg_cx2341x_video_luma_spatial_filter_type {
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF                  = 0,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR               = 1,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT              = 2,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE      = 3,
        V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE = 4,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE  (V4L2_CID_MPEG_CX2341X_BASE+3)
enum&nbsp;v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type {
        V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF    = 0,
        V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR = 1,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE        (V4L2_CID_MPEG_CX2341X_BASE+4)
enum&nbsp;v4l2_mpeg_cx2341x_video_temporal_filter_mode {
        V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL = 0,
        V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO   = 1,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER             (V4L2_CID_MPEG_CX2341X_BASE+5)
#define V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE          (V4L2_CID_MPEG_CX2341X_BASE+6)
enum&nbsp;v4l2_mpeg_cx2341x_video_median_filter_type {
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF      = 0,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR      = 1,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT     = 2,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT = 3,
        V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG     = 4,
};
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM   (V4L2_CID_MPEG_CX2341X_BASE+7)
#define V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP      (V4L2_CID_MPEG_CX2341X_BASE+8)
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM (V4L2_CID_MPEG_CX2341X_BASE+9)
#define V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP    (V4L2_CID_MPEG_CX2341X_BASE+10)
#define V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS         (V4L2_CID_MPEG_CX2341X_BASE+11)

/*  Camera class control IDs */
#define V4L2_CID_CAMERA_CLASS_BASE      (V4L2_CTRL_CLASS_CAMERA | 0x900)
#define V4L2_CID_CAMERA_CLASS           (V4L2_CTRL_CLASS_CAMERA | 1)

#define V4L2_CID_EXPOSURE_AUTO                  (V4L2_CID_CAMERA_CLASS_BASE+1)
enum&nbsp;v4l2_exposure_auto_type {
        V4L2_EXPOSURE_AUTO = 0,
        V4L2_EXPOSURE_MANUAL = 1,
        V4L2_EXPOSURE_SHUTTER_PRIORITY = 2,
        V4L2_EXPOSURE_APERTURE_PRIORITY = 3
};
#define V4L2_CID_EXPOSURE_ABSOLUTE              (V4L2_CID_CAMERA_CLASS_BASE+2)
#define V4L2_CID_EXPOSURE_AUTO_PRIORITY         (V4L2_CID_CAMERA_CLASS_BASE+3)

#define V4L2_CID_PAN_RELATIVE                   (V4L2_CID_CAMERA_CLASS_BASE+4)
#define V4L2_CID_TILT_RELATIVE                  (V4L2_CID_CAMERA_CLASS_BASE+5)
#define V4L2_CID_PAN_RESET                      (V4L2_CID_CAMERA_CLASS_BASE+6)
#define V4L2_CID_TILT_RESET                     (V4L2_CID_CAMERA_CLASS_BASE+7)

#define V4L2_CID_PAN_ABSOLUTE                   (V4L2_CID_CAMERA_CLASS_BASE+8)
#define V4L2_CID_TILT_ABSOLUTE                  (V4L2_CID_CAMERA_CLASS_BASE+9)

#define V4L2_CID_FOCUS_ABSOLUTE                 (V4L2_CID_CAMERA_CLASS_BASE+10)
#define V4L2_CID_FOCUS_RELATIVE                 (V4L2_CID_CAMERA_CLASS_BASE+11)
#define V4L2_CID_FOCUS_AUTO                     (V4L2_CID_CAMERA_CLASS_BASE+12)

/*
 *      T U N I N G
 */
struct <A
HREF="r12342.htm#V4L2-TUNER"
>v4l2_tuner</A
>
{
        __u32                   index;
        __u8                    name[32];
        enum <A
HREF="r12342.htm#V4L2-TUNER-TYPE"
>v4l2_tuner_type</A
>    type;
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   rxsubchans;
        __u32                   audmode;
        __s32                   signal;
        __s32                   afc;
        __u32                   reserved[4];
};

struct <A
HREF="r11430.htm#V4L2-MODULATOR"
>v4l2_modulator</A
>
{
        __u32                   index;
        __u8                    name[32];
        __u32                   capability;
        __u32                   rangelow;
        __u32                   rangehigh;
        __u32                   txsubchans;
        __u32                   reserved[4];
};

/*  Flags for the 'capability' field */
#define V4L2_TUNER_CAP_LOW              0x0001
#define V4L2_TUNER_CAP_NORM             0x0002
#define V4L2_TUNER_CAP_STEREO           0x0010
#define V4L2_TUNER_CAP_LANG2            0x0020
#define V4L2_TUNER_CAP_SAP              0x0020
#define V4L2_TUNER_CAP_LANG1            0x0040

/*  Flags for the 'rxsubchans' field */
#define V4L2_TUNER_SUB_MONO             0x0001
#define V4L2_TUNER_SUB_STEREO           0x0002
#define V4L2_TUNER_SUB_LANG2            0x0004
#define V4L2_TUNER_SUB_SAP              0x0004
#define V4L2_TUNER_SUB_LANG1            0x0008

/*  Values for the 'audmode' field */
#define V4L2_TUNER_MODE_MONO            0x0000
#define V4L2_TUNER_MODE_STEREO          0x0001
#define V4L2_TUNER_MODE_LANG2           0x0002
#define V4L2_TUNER_MODE_SAP             0x0002
#define V4L2_TUNER_MODE_LANG1           0x0003
#define V4L2_TUNER_MODE_LANG1_LANG2     0x0004

struct <A
HREF="r11094.htm#V4L2-FREQUENCY"
>v4l2_frequency</A
>
{
        __u32                 tuner;
        enum <A
HREF="r12342.htm#V4L2-TUNER-TYPE"
>v4l2_tuner_type</A
>  type;
        __u32                 frequency;
        __u32                 reserved[8];
};

/*
 *      A U D I O
 */
struct <A
HREF="r9539.htm#V4L2-AUDIO"
>v4l2_audio</A
>
{
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*  Flags for the 'capability' field */
#define V4L2_AUDCAP_STEREO              0x00001
#define V4L2_AUDCAP_AVL                 0x00002

/*  Flags for the 'mode' field */
#define V4L2_AUDMODE_AVL                0x00001

struct <A
HREF="r9688.htm#V4L2-AUDIOOUT"
>v4l2_audioout</A
>
{
        __u32   index;
        __u8    name[32];
        __u32   capability;
        __u32   mode;
        __u32   reserved[2];
};

/*
 *      M P E G   S E R V I C E S
 *
 *      NOTE: EXPERIMENTAL API
 */
#if 1 /*KEEP*/
#define V4L2_ENC_IDX_FRAME_I    (0)
#define V4L2_ENC_IDX_FRAME_P    (1)
#define V4L2_ENC_IDX_FRAME_B    (2)
#define V4L2_ENC_IDX_FRAME_MASK (0xf)

struct <A
HREF="r10211.htm#V4L2-ENC-IDX-ENTRY"
>v4l2_enc_idx_entry</A
> {
        __u64 offset;
        __u64 pts;
        __u32 length;
        __u32 flags;
        __u32 reserved[2];
};

#define V4L2_ENC_IDX_ENTRIES (64)
struct <A
HREF="r10211.htm#V4L2-ENC-IDX"
>v4l2_enc_idx</A
> {
        __u32 entries;
        __u32 entries_cap;
        __u32 reserved[4];
        struct <A
HREF="r10211.htm#V4L2-ENC-IDX-ENTRY"
>v4l2_enc_idx_entry</A
> entry[V4L2_ENC_IDX_ENTRIES];
};


#define V4L2_ENC_CMD_START      (0)
#define V4L2_ENC_CMD_STOP       (1)
#define V4L2_ENC_CMD_PAUSE      (2)
#define V4L2_ENC_CMD_RESUME     (3)

/* Flags for V4L2_ENC_CMD_STOP */
#define V4L2_ENC_CMD_STOP_AT_GOP_END    (1 &lt;&lt; 0)

struct <A
HREF="r8087.htm#V4L2-ENCODER-CMD"
>v4l2_encoder_cmd</A
> {
        __u32 cmd;
        __u32 flags;
        union {
                struct {
                        __u32 data[8];
                } raw;
        };
};

#endif


/*
 *      D A T A   S E R V I C E S   ( V B I )
 *
 *      Data services API by Michael Schimek
 */

/* Raw VBI */
struct <A
HREF="x7013.htm#V4L2-VBI-FORMAT"
>v4l2_vbi_format</A
>
{
        __u32   sampling_rate;          /* in 1 Hz */
        __u32   offset;
        __u32   samples_per_line;
        __u32   sample_format;          /* V4L2_PIX_FMT_* */
        __s32   start[2];
        __u32   count[2];
        __u32   flags;                  /* V4L2_VBI_* */
        __u32   reserved[2];            /* must be zero */
};

/*  VBI flags  */
#define V4L2_VBI_UNSYNC         (1&lt;&lt; 0)
#define V4L2_VBI_INTERLACED     (1&lt;&lt; 1)

/* Sliced VBI
 *
 *    This implements is a proposal V4L2 API to allow SLICED VBI
 * required for some hardware encoders. It should change without
 * notice in the definitive implementation.
 */

struct <A
HREF="x7236.htm#V4L2-SLICED-VBI-FORMAT"
>v4l2_sliced_vbi_format</A
>
{
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        __u32   io_size;
        __u32   reserved[2];            /* must be zero */
};

/* Teletext World System Teletext
   (WST), defined on ITU-R BT.653-2 */
#define V4L2_SLICED_TELETEXT_B          (0x0001)
/* Video Program System, defined on ETS 300 231*/
#define V4L2_SLICED_VPS                 (0x0400)
/* Closed Caption, defined on EIA-608 */
#define V4L2_SLICED_CAPTION_525         (0x1000)
/* Wide Screen System, defined on ITU-R BT1119.1 */
#define V4L2_SLICED_WSS_625             (0x4000)

#define V4L2_SLICED_VBI_525             (V4L2_SLICED_CAPTION_525)
#define V4L2_SLICED_VBI_625             (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)

struct <A
HREF="r12051.htm#V4L2-SLICED-VBI-CAP"
>v4l2_sliced_vbi_cap</A
>
{
        __u16   service_set;
        /* service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
           service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
                                 (equals frame lines 313-336 for 625 line video
                                  standards, 263-286 for 525 line standards) */
        __u16   service_lines[2][24];
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
> type;
        __u32   reserved[3];    /* must be 0 */
};

struct <A
HREF="x7236.htm#V4L2-SLICED-VBI-DATA"
>v4l2_sliced_vbi_data</A
>
{
        __u32   id;
        __u32   field;          /* 0: first field, 1: second field */
        __u32   line;           /* 1-23 */
        __u32   reserved;       /* must be 0 */
        __u8    data[48];
};

/*
 *      A G G R E G A T E   S T R U C T U R E S
 */

/*      Stream data format
 */
struct <A
HREF="r10944.htm#V4L2-FORMAT"
>v4l2_format</A
>
{
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
> type;
        union
        {
                struct <A
HREF="c2030.htm#V4L2-PIX-FORMAT"
>v4l2_pix_format</A
>          pix;     // V4L2_BUF_TYPE_VIDEO_CAPTURE
                struct <A
HREF="x6570.htm#V4L2-WINDOW"
>v4l2_window</A
>              win;     // V4L2_BUF_TYPE_VIDEO_OVERLAY
                struct <A
HREF="x7013.htm#V4L2-VBI-FORMAT"
>v4l2_vbi_format</A
>          vbi;     // V4L2_BUF_TYPE_VBI_CAPTURE
                struct <A
HREF="x7236.htm#V4L2-SLICED-VBI-FORMAT"
>v4l2_sliced_vbi_format</A
>   sliced;  // V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
                __u8    raw_data[200];                   // user-defined
        } fmt;
};


/*      Stream type-dependent parameters
 */
struct <A
HREF="r11680.htm#V4L2-STREAMPARM"
>v4l2_streamparm</A
>
{
        enum <A
HREF="x5953.htm#V4L2-BUF-TYPE"
>v4l2_buf_type</A
> type;
        union
        {
                struct <A
HREF="r11680.htm#V4L2-CAPTUREPARM"
>v4l2_captureparm</A
> capture;
                struct <A
HREF="r11680.htm#V4L2-OUTPUTPARM"
>v4l2_outputparm</A
>  output;
                __u8    raw_data[200];  /* user-defined */
        } parm;
};

/*
 *      A D V A N C E D   D E B U G G I N G
 *
 *      NOTE: EXPERIMENTAL API
 */

/* VIDIOC_DBG_G_REGISTER and VIDIOC_DBG_S_REGISTER */

#define V4L2_CHIP_MATCH_HOST       0  /* Match against chip ID on host (0 for the host) */
#define V4L2_CHIP_MATCH_I2C_DRIVER 1  /* Match against I2C driver ID */
#define V4L2_CHIP_MATCH_I2C_ADDR   2  /* Match against I2C 7-bit address */

struct <A
HREF="r7900.htm#V4L2-REGISTER"
>v4l2_register</A
> {
        __u32 match_type; /* Match type */
        __u32 match_chip; /* Match this chip, meaning determined by match_type */
        __u64 reg;
        __u64 val;
};

/* VIDIOC_G_CHIP_IDENT */
struct <A
HREF="r9804.htm#V4L2-CHIP-IDENT"
>v4l2_chip_ident</A
> {
        __u32 match_type;  /* Match type */
        __u32 match_chip;  /* Match this chip, meaning determined by match_type */
        __u32 ident;       /* chip identifier as specified in &lt;media/v4l2-chip-ident.h&gt; */
        __u32 revision;    /* chip revision, chip specific */
};

/*
 *      I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
 *
 */
#define VIDIOC_QUERYCAP         _IOR  ('V',  0, struct <A
HREF="r13105.htm#V4L2-CAPABILITY"
>v4l2_capability</A
>)
#define VIDIOC_RESERVED         _IO   ('V',  1)
#define VIDIOC_ENUM_FMT         _IOWR ('V',  2, struct <A
HREF="r8367.htm#V4L2-FMTDESC"
>v4l2_fmtdesc</A
>)
#define VIDIOC_G_FMT            _IOWR ('V',  4, struct <A
HREF="r10944.htm#V4L2-FORMAT"
>v4l2_format</A
>)
#define VIDIOC_S_FMT            _IOWR ('V',  5, struct <A
HREF="r10944.htm#V4L2-FORMAT"
>v4l2_format</A
>)
#define VIDIOC_REQBUFS          _IOWR ('V',  8, struct <A
HREF="r13696.htm#V4L2-REQUESTBUFFERS"
>v4l2_requestbuffers</A
>)
#define VIDIOC_QUERYBUF         _IOWR ('V',  9, struct <A
HREF="x5953.htm#V4L2-BUFFER"
>v4l2_buffer</A
>)
#define VIDIOC_G_FBUF           _IOR  ('V', 10, struct <A
HREF="r10595.htm#V4L2-FRAMEBUFFER"
>v4l2_framebuffer</A
>)
#define VIDIOC_S_FBUF           _IOW  ('V', 11, struct <A
HREF="r10595.htm#V4L2-FRAMEBUFFER"
>v4l2_framebuffer</A
>)
#define VIDIOC_OVERLAY          _IOW  ('V', 14, int)
#define VIDIOC_QBUF             _IOWR ('V', 15, struct <A
HREF="x5953.htm#V4L2-BUFFER"
>v4l2_buffer</A
>)
#define VIDIOC_DQBUF            _IOWR ('V', 17, struct <A
HREF="x5953.htm#V4L2-BUFFER"
>v4l2_buffer</A
>)
#define VIDIOC_STREAMON         _IOW  ('V', 18, int)
#define VIDIOC_STREAMOFF        _IOW  ('V', 19, int)
#define VIDIOC_G_PARM           _IOWR ('V', 21, struct <A
HREF="r11680.htm#V4L2-STREAMPARM"
>v4l2_streamparm</A
>)
#define VIDIOC_S_PARM           _IOWR ('V', 22, struct <A
HREF="r11680.htm#V4L2-STREAMPARM"
>v4l2_streamparm</A
>)
#define VIDIOC_G_STD            _IOR  ('V', 23, v4l2_std_id)
#define VIDIOC_S_STD            _IOW  ('V', 24, v4l2_std_id)
#define VIDIOC_ENUMSTD          _IOWR ('V', 25, struct <A
HREF="r9288.htm#V4L2-STANDARD"
>v4l2_standard</A
>)
#define VIDIOC_ENUMINPUT        _IOWR ('V', 26, struct <A
HREF="r8936.htm#V4L2-INPUT"
>v4l2_input</A
>)
#define VIDIOC_G_CTRL           _IOWR ('V', 27, struct <A
HREF="r10104.htm#V4L2-CONTROL"
>v4l2_control</A
>)
#define VIDIOC_S_CTRL           _IOWR ('V', 28, struct <A
HREF="r10104.htm#V4L2-CONTROL"
>v4l2_control</A
>)
#define VIDIOC_G_TUNER          _IOWR ('V', 29, struct <A
HREF="r12342.htm#V4L2-TUNER"
>v4l2_tuner</A
>)
#define VIDIOC_S_TUNER          _IOW  ('V', 30, struct <A
HREF="r12342.htm#V4L2-TUNER"
>v4l2_tuner</A
>)
#define VIDIOC_G_AUDIO          _IOR  ('V', 33, struct <A
HREF="r9539.htm#V4L2-AUDIO"
>v4l2_audio</A
>)
#define VIDIOC_S_AUDIO          _IOW  ('V', 34, struct <A
HREF="r9539.htm#V4L2-AUDIO"
>v4l2_audio</A
>)
#define VIDIOC_QUERYCTRL        _IOWR ('V', 36, struct <A
HREF="r13317.htm#V4L2-QUERYCTRL"
>v4l2_queryctrl</A
>)
#define VIDIOC_QUERYMENU        _IOWR ('V', 37, struct <A
HREF="r13317.htm#V4L2-QUERYMENU"
>v4l2_querymenu</A
>)
#define VIDIOC_G_INPUT          _IOR  ('V', 38, int)
#define VIDIOC_S_INPUT          _IOWR ('V', 39, int)
#define VIDIOC_G_OUTPUT         _IOR  ('V', 46, int)
#define VIDIOC_S_OUTPUT         _IOWR ('V', 47, int)
#define VIDIOC_ENUMOUTPUT       _IOWR ('V', 48, struct <A
HREF="r9149.htm#V4L2-OUTPUT"
>v4l2_output</A
>)
#define VIDIOC_G_AUDOUT         _IOR  ('V', 49, struct <A
HREF="r9688.htm#V4L2-AUDIOOUT"
>v4l2_audioout</A
>)
#define VIDIOC_S_AUDOUT         _IOW  ('V', 50, struct <A
HREF="r9688.htm#V4L2-AUDIOOUT"
>v4l2_audioout</A
>)
#define VIDIOC_G_MODULATOR      _IOWR ('V', 54, struct <A
HREF="r11430.htm#V4L2-MODULATOR"
>v4l2_modulator</A
>)
#define VIDIOC_S_MODULATOR      _IOW  ('V', 55, struct <A
HREF="r11430.htm#V4L2-MODULATOR"
>v4l2_modulator</A
>)
#define VIDIOC_G_FREQUENCY      _IOWR ('V', 56, struct <A
HREF="r11094.htm#V4L2-FREQUENCY"
>v4l2_frequency</A
>)
#define VIDIOC_S_FREQUENCY      _IOW  ('V', 57, struct <A
HREF="r11094.htm#V4L2-FREQUENCY"
>v4l2_frequency</A
>)
#define VIDIOC_CROPCAP          _IOWR ('V', 58, struct <A
HREF="r7771.htm#V4L2-CROPCAP"
>v4l2_cropcap</A
>)
#define VIDIOC_G_CROP           _IOWR ('V', 59, struct <A
HREF="r9994.htm#V4L2-CROP"
>v4l2_crop</A
>)
#define VIDIOC_S_CROP           _IOW  ('V', 60, struct <A
HREF="r9994.htm#V4L2-CROP"
>v4l2_crop</A
>)
#define VIDIOC_G_JPEGCOMP       _IOR  ('V', 61, struct <A
HREF="r11285.htm#V4L2-JPEGCOMPRESSION"
>v4l2_jpegcompression</A
>)
#define VIDIOC_S_JPEGCOMP       _IOW  ('V', 62, struct <A
HREF="r11285.htm#V4L2-JPEGCOMPRESSION"
>v4l2_jpegcompression</A
>)
#define VIDIOC_QUERYSTD         _IOR  ('V', 63, v4l2_std_id)
#define VIDIOC_TRY_FMT          _IOWR ('V', 64, struct <A
HREF="r10944.htm#V4L2-FORMAT"
>v4l2_format</A
>)
#define VIDIOC_ENUMAUDIO        _IOWR ('V', 65, struct <A
HREF="r9539.htm#V4L2-AUDIO"
>v4l2_audio</A
>)
#define VIDIOC_ENUMAUDOUT       _IOWR ('V', 66, struct <A
HREF="r9688.htm#V4L2-AUDIOOUT"
>v4l2_audioout</A
>)
#define VIDIOC_G_PRIORITY       _IOR  ('V', 67, enum <A
HREF="r11946.htm#V4L2-PRIORITY"
>v4l2_priority</A
>)
#define VIDIOC_S_PRIORITY       _IOW  ('V', 68, enum <A
HREF="r11946.htm#V4L2-PRIORITY"
>v4l2_priority</A
>)
#define VIDIOC_G_SLICED_VBI_CAP _IOWR ('V', 69, struct <A
HREF="r12051.htm#V4L2-SLICED-VBI-CAP"
>v4l2_sliced_vbi_cap</A
>)
#define VIDIOC_LOG_STATUS       _IO   ('V', 70)
#define VIDIOC_G_EXT_CTRLS      _IOWR ('V', 71, struct <A
HREF="r10386.htm#V4L2-EXT-CONTROLS"
>v4l2_ext_controls</A
>)
#define VIDIOC_S_EXT_CTRLS      _IOWR ('V', 72, struct <A
HREF="r10386.htm#V4L2-EXT-CONTROLS"
>v4l2_ext_controls</A
>)
#define VIDIOC_TRY_EXT_CTRLS    _IOWR ('V', 73, struct <A
HREF="r10386.htm#V4L2-EXT-CONTROLS"
>v4l2_ext_controls</A
>)
#if 1 /*KEEP*/
#define VIDIOC_ENUM_FRAMESIZES  _IOWR ('V', 74, struct <A
HREF="r8494.htm#V4L2-FRMSIZEENUM"
>v4l2_frmsizeenum</A
>)
#define VIDIOC_ENUM_FRAMEINTERVALS      _IOWR ('V', 75, struct <A
HREF="r8724.htm#V4L2-FRMIVALENUM"
>v4l2_frmivalenum</A
>)
#define VIDIOC_G_ENC_INDEX      _IOR  ('V', 76, struct <A
HREF="r10211.htm#V4L2-ENC-IDX"
>v4l2_enc_idx</A
>)
#define VIDIOC_ENCODER_CMD      _IOWR ('V', 77, struct <A
HREF="r8087.htm#V4L2-ENCODER-CMD"
>v4l2_encoder_cmd</A
>)
#define VIDIOC_TRY_ENCODER_CMD  _IOWR ('V', 78, struct <A
HREF="r8087.htm#V4L2-ENCODER-CMD"
>v4l2_encoder_cmd</A
>)

/* Experimental, only implemented if CONFIG_VIDEO_ADV_DEBUG is defined */
#define VIDIOC_DBG_S_REGISTER   _IOW  ('V', 79, struct <A
HREF="r7900.htm#V4L2-REGISTER"
>v4l2_register</A
>)
#define VIDIOC_DBG_G_REGISTER   _IOWR ('V', 80, struct <A
HREF="r7900.htm#V4L2-REGISTER"
>v4l2_register</A
>)

#define VIDIOC_G_CHIP_IDENT     _IOWR ('V', 81, struct <A
HREF="r9804.htm#V4L2-CHIP-IDENT"
>v4l2_chip_ident</A
>)
#endif

#ifdef __OLD_VIDIOC_
/* for compatibility, will go away some day */
#define VIDIOC_OVERLAY_OLD      _IOWR ('V', 14, int)
#define VIDIOC_S_PARM_OLD       _IOW  ('V', 22, struct <A
HREF="r11680.htm#V4L2-STREAMPARM"
>v4l2_streamparm</A
>)
#define VIDIOC_S_CTRL_OLD       _IOW  ('V', 28, struct <A
HREF="r10104.htm#V4L2-CONTROL"
>v4l2_control</A
>)
#define VIDIOC_G_AUDIO_OLD      _IOWR ('V', 33, struct <A
HREF="r9539.htm#V4L2-AUDIO"
>v4l2_audio</A
>)
#define VIDIOC_G_AUDOUT_OLD     _IOWR ('V', 49, struct <A
HREF="r9688.htm#V4L2-AUDIOOUT"
>v4l2_audioout</A
>)
#define VIDIOC_CROPCAP_OLD      _IOR  ('V', 58, struct <A
HREF="r7771.htm#V4L2-CROPCAP"
>v4l2_cropcap</A
>)
#endif

#define BASE_VIDIOC_PRIVATE     192             /* 192-255 are private */

#endif /* __LINUX_VIDEODEV2_H */

/*
 * Local variables:
 * c-basic-offset: 8
 * End:
 */</PRE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x16497.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="a16706.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Obsolete API Elements</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Video Capture Example</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
