# This file is a Tcl script to test entry widgets in Tk.  It is
# organized in the standard fashion for Tcl tests.
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @(#) $Id: panedwindow.test,v 1.1 2005/03/22 17:52:20 mridge Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

set i 1
panedwindow .p
foreach test {
    {-background "#ff0000" "#ff0000" non-existent 
	{unknown color name "non-existent"}}
    {-bd 4 4 badValue {bad screen distance "badValue"}}
    {-bg "#ff0000" "#ff0000" non-existent {unknown color name "non-existent"}}
    {-borderwidth 1.3 1 badValue {bad screen distance "badValue"}}
    {-cursor arrow arrow badValue {bad cursor spec "badValue"}}
    {-handlesize 20 20 badValue {bad screen distance "badValue"}}
    {-height 20 20 badValue {bad screen distance "badValue"}}
    {-opaqueresize true 1 foo {expected boolean value but got "foo"}}
    {-orient horizontal horizontal badValue 
	{bad orient "badValue": must be horizontal or vertical}}
    {-relief groove groove 1.5 {bad relief "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
    {-sashcursor arrow arrow badValue {bad cursor spec "badValue"}}
    {-sashpad 1.3 1 badValue {bad screen distance "badValue"}}
    {-sashrelief groove groove 1.5 {bad relief "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
    {-sashwidth 10 10 badValue {bad screen distance "badValue"}}
    {-showhandle true 1 foo {expected boolean value but got "foo"}}
    {-width 402 402 badValue {bad screen distance "badValue"}}
} {
    set name [lindex $test 0]
    test panedwindow-1.$i {configuration options} {
	.p configure $name [lindex $test 1]
	list [lindex [.p configure $name] 4] [.p cget $name]
    } [list [lindex $test 2] [lindex $test 2]]
    incr i
    if {[lindex $test 3] != ""} {
	test entry-1.$i {configuration options} {
	    list [catch {.p configure $name [lindex $test 3]} msg] $msg
	} [list 1 [lindex $test 4]]
    }
    .p configure $name [lindex [.p configure $name] 3]
    incr i
}
.p add [button .b]
.p add [button .c]
foreach test {
    {-after .c .c badValue {bad window path name "badValue"}}
    {-before .c .c badValue {bad window path name "badValue"}}
    {-height 10 10 badValue {bad screen distance "badValue"}}
    {-minsize 10 10 badValue {bad screen distance "badValue"}}
    {-padx 1.3 1 badValue {bad screen distance "badValue"}}
    {-pady 1.3 1 badValue {bad screen distance "badValue"}}
    {-sticky nsew nesw abcd {bad stickyness value "abcd": must be a string containing zero or more of n, e, s, and w}}
    {-width 10 10 badValue {bad screen distance "badValue"}}
} {
    set name [lindex $test 0]
    test panedwindow-1.$i {configuration options} {
	.p paneconfigure .b $name [lindex $test 1]
	list [lindex [.p paneconfigure .b $name] 4] [.p panecget .b $name]
    } [list [lindex $test 2] [lindex $test 2]]
    incr i
    if {[lindex $test 3] != ""} {
	test entry-1.$i {configuration options} {
	    list [catch {.p paneconfigure .b $name [lindex $test 3]} msg] $msg
	} [list 1 [lindex $test 4]]
    }
    .p paneconfigure .b $name [lindex [.p paneconfigure .b $name] 3]
    incr i
}
destroy .p .b .c

test panedwindow-2.1 {panedwindow widget command} {
    panedwindow .p
    set result [list [catch {.p foo} msg] $msg]
    destroy .p
    set result
} {1 {bad command "foo": must be add, cget, configure, forget, identify, panecget, paneconfigure, panes, proxy, or sash}}

test panedwindow-3.1 {panedwindow panes subcommand} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    set result [list [.p panes]]
    .p forget .b
    lappend result [.p panes]
    destroy .p .b .c
    set result
} [list [list .b .c] [list .c]]

test panedwindow-4.1 {forget subcommand} {
    panedwindow .p
    set result [list [catch {.p forget} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p forget widget ?widget ...?\""]
test panedwindow-4.2 {forget subcommand, forget one from start} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    set result [list [.p panes]]
    .p forget .b
    lappend result [.p panes]
    destroy .p .b .c
    set result
} [list {.b .c} .c]
test panedwindow-4.3 {forget subcommand, forget one from end} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    .p add [button .d]
    set result [list [.p panes]]
    .p forget .d
    update
    lappend result [.p panes]
    destroy .p .b .c .d
    set result
} [list {.b .c .d} {.b .c}]
test panedwindow-4.4 {forget subcommand, forget multiple} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    .p add [button .d]
    set result [list [.p panes]]
    .p forget .b .c
    update
    lappend result [.p panes]
    destroy .p .b .c .d
    set result
} [list {.b .c .d} .d]
test panedwindow-4.5 {forget subcommand, panes are unmapped} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    pack .p
    update

    set result [list [winfo ismapped .b] [winfo ismapped .c]]
    .p forget .b
    update

    lappend result [winfo ismapped .b] [winfo ismapped .c]
    destroy .p .b .c
    
    set result
} [list 1 1 0 1]
test panedwindow-4.6 {forget subcommand, changes reqsize of panedwindow} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [frame .g -width 20 -height 20]
    set result [list [winfo reqwidth .p]]
    .p forget .f
    lappend result [winfo reqwidth .p]
    destroy .p .f .g
    set result
} [list 44 20]

test panedwindow-5.1 {sash subcommand} {
    panedwindow .p
    set result [list [catch {.p sash} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash option ?arg ...?\""]
test panedwindow-5.2 {sash subcommand} {
    panedwindow .p
    set result [list [catch {.p sash foo} msg] $msg]
    destroy .p
    set result
} [list 1 "bad option \"foo\": must be coord, dragto, mark, or place"]

test panedwindow-6.1 {sash coord subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash coord} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash coord index\""]
test panedwindow-6.2 {sash coord subcommand, errors} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4
    set result [list [catch {.p sash coord 0} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-6.3 {sash coord subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash coord foo} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-6.4 {sash coord subcommand sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 0]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 22 0]
test panedwindow-6.5 {sash coord subcommand sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 1]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 50 0]
test panedwindow-6.6 {sash coord subcommand, sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -orient vertical \
            -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 0]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 0 22]
test panedwindow-6.7 {sash coord subcommand, sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -orient vertical \
            -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 1]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 0 50]
test panedwindow-6.8 {sash coord subcommand, errors} {
    panedwindow .p
    set result [list \
	    [catch {.p sash coord -1} msg] $msg \
	    [catch {.p sash coord  0} msg] $msg \
	    [catch {.p sash coord  1} msg] $msg \
	    ]
    destroy .p
    set result
} [list 1 "invalid sash index" 1 "invalid sash index" 1 "invalid sash index"]
test panedwindow-6.9 {sash coord subcommand, errors} {
    panedwindow .p
    .p add [frame .p.f]
    set result [list \
	    [catch {.p sash coord -1} msg] $msg \
	    [catch {.p sash coord  0} msg] \
	    [catch {.p sash coord  1} msg] $msg \
	    ]
    destroy .p
    set result
} [list 1 "invalid sash index" 0 1 "invalid sash index"]

test panedwindow-8.1 {sash mark subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash mark} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash mark index ?x y?\""]
test panedwindow-8.2 {sash mark subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash mark foo} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-8.3 {sash mark subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash mark 0 foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-8.4 {sash mark subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash mark 0 foo bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-8.5 {sash mark subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash mark 0 0 bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"bar\""]
test panedwindow-8.6 {sash mark subcommand, mark defaults to 0 0} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [.p sash mark 0]
    destroy .p .b .c
    set result
} [list 0 0]
test panedwindow-8.7 {sash mark subcommand, set mark} {
    panedwindow .p
    .p add [button .b] [button .c]
    .p sash mark 0 10 10
    set result [.p sash mark 0]
    destroy .p .b .c
    set result
} [list 10 10]

test panedwindow-9.1 {sash dragto subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash dragto} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash dragto index x y\""]
test panedwindow-9.2 {sash dragto subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash dragto foo bar baz} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-9.3 {sash dragto subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash dragto 0 foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-9.4 {sash dragto subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash dragto 0 foo bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-9.5 {sash dragto subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash dragto 0 0 bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"bar\""]
    
test panedwindow-10.1 {sash mark/sash dragto interaction} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c -text foobar]
    .p sash mark 0 10 10
    .p sash dragto 0 20 10
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 30 0]
test panedwindow-10.2 {sash mark/sash dragto interaction} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -orient vertical \
            -showhandle false
    .p add [frame .p.f -width 20 -height 20] [button .p.c -text foobar]
    .p sash mark 0 10 10
    .p sash dragto 0 10 20
    set result [.p sash coord 0]
    destroy .p .p.f .p.c
    set result
} [list 0 30]
test panedwindow-10.3 {sash mark/sash dragto, respects minsize}  {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c] -minsize 15
    .p sash mark 0 20 10
    .p sash dragto 0 10 10
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 15 0]

test panedwindow-11.1 {sash place subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash place} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash place index x y\""]
test panedwindow-11.2 {sash place subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash place foo bar baz} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-11.3 {sash place subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash place 0 foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-11.4 {sash place subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash place 0 foo bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-11.5 {sash place subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash place 0 0 bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"bar\""]
test panedwindow-11.6 {sash place subcommand, moves sash} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [button .c]
    .p sash place 0 10 0
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 10 0]
test panedwindow-11.7 {sash place subcommand, moves sash} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -orient vertical
    .p add [frame .f -width 20 -height 20] [button .c]
    .p sash place 0 0 10
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 0 10]
test panedwindow-11.8 {sash place subcommand, respects minsize} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c] -minsize 15
    .p sash place 0 10 0
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 15 0]

test panedwindow-12.1 {moving sash changes size of pane to left} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c -text foobar] -sticky nsew
    .p sash place 0 30 0
    pack .p
    update
    set result [winfo width .f]
    destroy .p .f .c
    set result
} 30
test panedwindow-12.2 {moving sash changes size of pane to right} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [frame .f2 -width 20 -height 20]
    pack .p
    update
    set result [winfo width .f2]
    .p sash place 0 30 0
    update
    lappend result [winfo width .f2]
    destroy .p .f .f2
    set result
} {20 10}
test panedwindow-12.3 {moving sash does not change reqsize of panedwindow} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [frame .f2 -width 20 -height 20]
    .p sash place 0 30 0
    set result [winfo reqwidth .p]
    destroy .p .f .f2
    set result
} 44
test panedwindow-12.4 {moving sash changes size of pane above} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [button .c -text foobar] -sticky nsew
    .p sash place 0 0 20
    pack .p
    update
    set result [winfo height .f]
    destroy .p .f .c
    set result
} 20
test panedwindow-12.5 {moving sash changes size of pane below} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [frame .f2 -width 20 -height 10]
    pack .p
    update
    set result [winfo height .f2]
    .p sash place 0 0 15
    update
    lappend result [winfo height .f2]
    destroy .p .f .f2
    set result
} {10 5}
test panedwindow-12.6 {moving sash does not change reqsize of panedwindow} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [frame .f2 -width 20 -height 10]
    set result [winfo reqheight .p]
    .p sash place 0 0 20
    lappend result [winfo reqheight .p]
    destroy .p .f .f2
    set result
} [list 24 24]
test panedwindow-12.7 {moving sash does not alter reqsize of widget} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [frame .f2 -width 20 -height 10]
    set result [winfo reqheight .f]
    .p sash place 0 0 20
    lappend result [winfo reqheight .f]
    destroy .p .f .f2
    set result
} [list 10 10]
test panedwindow-12.8 {moving sash restricted to minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [button .c] -minsize 15
    .p sash place 0 10 0
    pack .p
    update
    set result [winfo width .f]
    destroy .p .f .c
    set result
} 15
test panedwindow-12.10 {moving sash restricted to minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 30] [button .c] -minsize 10
    .p sash place 0 0 5
    pack .p
    update
    set result [winfo height .f]
    destroy .p .f .c
    set result
} 10
test panedwindow-12.12 {moving sash in unmapped window restricted to reqsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20]
    set result [list [.p sash coord 0]]
    .p sash place 0 100 0
    lappend result [.p sash coord 0]
    destroy .p .f .f2
    set result
} [list {20 0} {40 0}]
test panedwindow-12.13 {moving sash right pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    .p sash place 0 80 0
    set result [list [.p sash coord 0] [.p sash coord 1]]
    destroy .p .f .f2 .f3
    set result
} {{60 0} {64 0}}
test panedwindow-12.14 {moving sash left pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    .p sash place 1 0 0
    set result [list [.p sash coord 0] [.p sash coord 1]]
    destroy .p .f .f2 .f3
    set result
} {{0 0} {4 0}}
test panedwindow-12.15 {move sash in mapped window restricted to visible win} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    place .p -width 50
    update
    .p sash place 1 100 0
    update
    set result [.p sash coord 1]
    destroy .p .f .f2 .f3
    set result
} {46 0}
test panedwindow-12.16 {move sash in mapped window restricted to visible win} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    place .p -width 100
    update
    .p sash place 1 200 0
    update
    set result [.p sash coord 1]
    destroy .p .f .f2 .f3
    set result
} {96 0}
test panedwindow-12.17 {moving sash into "virtual" space on \
	last pane increases reqsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    place .p -width 100
    set result [winfo reqwidth .p]
    update
    .p sash place 1 200 0
    update
    lappend result [winfo reqwidth .p]
    destroy .p .f .f2 .f3
    set result
} {68 100}
    
test panedwindow-13.1 {horizontal panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 2 -sashpad 2 -sashwidth 2
    foreach win {.p.f .p.f2 .p.f3} {.p add [frame $win -width 20 -height 10]}
    pack .p
    update
    set result {}
    foreach w [.p panes] {lappend result [winfo x $w] [winfo y $w]}
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 2 2 28 2 54 2]
test panedwindow-13.2 {vertical panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 2 -sashpad 2 -sashwidth 2 \
            -orient vertical
    foreach win {.p.f .p.f2 .p.f3} {.p add [frame $win -width 20 -height 10]}
    pack .p
    update
    set result {}
    foreach w [.p panes] {lappend result [winfo x $w] [winfo y $w]}
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 2 2 2 18 2 34]
test panedwindow-13.3 {horizontal panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach {win color} {.p.f blue .p.f2 green} {
	.p add [frame $win -width 20 -height 20 -bg $color] -padx 10 -pady 5 \
                -sticky ""
    }
    pack .p
    update
    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    .p paneconfigure .p.f -padx 0 -pady 0
    update
    lappend result [winfo reqwidth .p] [winfo reqheight .p]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    destroy .p .p.f .p.f2
    set result
} [list 80 30 10 5 50 5 60 30 0 5 30 5]
test panedwindow-13.4 {vertical panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach win {.p.f .p.f2} {
	.p add [frame $win -width 20 -height 20] -padx 10 -pady 5 -sticky ""
    }
    pack .p
    update
    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    .p paneconfigure .p.f -padx 0 -pady 0
    update
    lappend result [winfo reqwidth .p] [winfo reqheight .p]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    destroy .p .p.f .p.f2
    set result
} [list 40 60 10 5 10 35 40 50 10 0 10 25]
test panedwindow-13.5 {panedwindow respects reqsize of panes when possible} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -sticky ""
    place .p -width 40
    update
    set result [list [winfo width .p.f]]
    .p.f configure -width 30
    update
    lappend result [winfo width .p.f]
    destroy .p .p.f
    set result
} [list 20 30]
test panedwindow-13.6 {panedwindow takes explicit widget width over reqwidth} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -width 20 -sticky ""
    place .p -width 40
    update
    set result [list [winfo width .p.f]]
    .p.f configure -width 30
    update
    lappend result [winfo width .p.f]
    destroy .p .p.f
    set result
} [list 20 20]
test panedwindow-13.7 {horizontal panedwindow reqheight is max slave height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .p.f -width 20 -height 20] [frame .p.f2 -width 20 -height 20]
    set result [winfo reqheight .p]
    .p.f config -height 40
    lappend result [winfo reqheight .p]
    destroy .p .p.f .p.f2
    set result
} {20 40}
test panedwindow-13.8 {horizontal panedwindow reqheight is max slave height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p paneconfigure .p.f -height 15
    set result [winfo reqheight .p]
    .p.f config -height 40
    lappend result [winfo reqheight .p]
    destroy .p .p.f .p.f2
    set result
} {20 20}
test panedwindow-13.9 {panedwindow pane width overrides widget width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p sash place 0 10 0
    pack .p
    update
    set result [winfo width .p.f]
    .p paneconfigure .p.f -width 30
    lappend result [winfo width .p.f]
    destroy .p .p.f .p.f2
    set result
} [list 10 10]
test panedwindow-13.10 {panedwindow respects reqsize of panes when possible} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -sticky ""
    place .p -height 40
    update
    set result [list [winfo height .p.f]]
    .p.f configure -height 30
    update
    lappend result [winfo height .p.f]
    destroy .p .p.f
    set result
} [list 20 30]
test panedwindow-13.11 {panedwindow takes explicit height over reqheight} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -height 20 -sticky ""
    place .p -height 40
    update
    set result [list [winfo height .p.f]]
    .p.f configure -height 30
    update
    lappend result [winfo height .p.f]
    destroy .p .p.f
    set result
} [list 20 20]
test panedwindow-13.12 {vertical panedwindow reqwidth is max slave width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .p.f -width 20 -height 20] [frame .p.f2 -width 20 -height 20]
    set result [winfo reqwidth .p]
    .p.f config -width 40
    lappend result [winfo reqwidth .p]
    destroy .p .p.f .p.f2
    set result
} {20 40}
test panedwindow-13.13 {vertical panedwindow reqwidth is max slave width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p paneconfigure .p.f -width 15
    set result [winfo reqwidth .p]
    .p.f config -width 40
    lappend result [winfo reqwidth .p]
    destroy .p .p.f .p.f2
    set result
} {20 20}
test panedwindow-13.14 {panedwindow pane height overrides widget width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p sash place 0 0 10
    pack .p
    update
    set result [winfo height .p.f]
    .p paneconfigure .p.f -height 30
    lappend result [winfo height .p.f]
    destroy .p .p.f .p.f2
    set result
} [list 10 10]


test panedwindow-14.1 {PanestructureProc, widget yields managements} {
    # Check that the panedwindow correctly yields geometry management of
    # a slave when the slave is destroyed.

    # This test should not cause a core dump, and it should not cause
    # a memory leak.
    panedwindow .p
    .p add [button .b]
    destroy .p
    pack .b
    destroy .b
    set result ""
} ""
test panedwindow-14.2 {PanedWindowLostSlaveProc, widget yields management} {
    # Check that the paned window correctly yields geometry management of
    # a slave when some other geometry manager steals the slave from us.
    
    # This test should not cause a core dump, and it should not cause a
    # memory leak.
    panedwindow .p
    .p add [button .b]
    pack .p
    update
    pack .b
    update
    set result [.p panes]
    destroy .p .b
    set result
} {}

set stickysets [list n s e w sn ns en ne wn nw esn nse nsw nsew ""]
set stickygets [list n s e w ns ns ne ne nw nw nes nes nsw nesw ""]
set i 0
foreach s $stickysets g $stickygets {
    test panedwindow-15.[incr i] {panedwindow sticky settings} {
	panedwindow .p -showhandle false
	.p add [button .b]
	.p paneconfigure .b -sticky $s
	set result [.p panecget .b -sticky]
	destroy .p .b
	set result
    } $g
}

set i 0
foreach s [list {}  n  s  e  w ns ew nw ne se sw nse nsw sew new news] \
	x [list 10 10 10 20  0 10  0  0 20 20  0  20   0   0   0    0] \
	y [list 10  0 20 10 10  0 10  0  0 20 20   0   0  20   0    0] \
	w [list 20 20 20 20 20 20 40 20 20 20 20  20  20  40  40   40] \
	h [list 20 20 20 20 20 40 20 20 20 20 20  40  40  20  20   40] {
    test panedwindow-16.[incr i] {panedwindow sticky works} {
	panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
	.p add [frame .p.f -height 20 -width 20 -bg red] -sticky $s
	place .p -width 40 -height 40
	update
	set result [list $s [winfo x .p.f] [winfo y .p.f] \
		[winfo width .p.f] [winfo height .p.f]]
	destroy .p .p.f
	set result
    } [list $s $x $y $w $h]
}

test panedwindow-17.1 {setting minsize when pane is too small snaps width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .p.f -height 20 -width 20 -bg red]
    set result [winfo reqwidth .p]
    .p paneconfigure .p.f -minsize 40
    lappend result [winfo reqwidth .p]
    destroy .p .p.f .p.f2
    set result
} [list 20 40]

test panedwindow-18.1 {MoveSash, move right} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqwidth .p]
    
    .p sash place 0 30 0
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqwidth .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {30 0}]
test panedwindow-18.2 {MoveSash, move right (unmapped) clipped by reqwidth} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should be clipped by the reqwidth of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 40 0]
test panedwindow-18.3 {MoveSash, move right (mapped, width < reqwidth) clipped by width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a width < reqwidth
    place .p -x 0 -y 0 -width 32
    update

    .p sash place 0 100 0
    
    # Get the new sash coord; it should be clipped by the visible width of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 30 0]
test panedwindow-18.4 {MoveSash, move right (mapped, width > reqwidth) clipped by width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a width > reqwidth
    place .p -x 0 -y 0 -width 102
    update

    .p sash place 0 200 0
    
    # Get the new sash coord; it should be clipped by the visible width of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 100 0]
test panedwindow-18.5 {MoveSash, move right respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 30 0]
test panedwindow-18.6 {MoveSash, move right respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 40 0]
test panedwindow-18.7 {MoveSash, move right pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 62 0]
test panedwindow-18.8 {MoveSash, move right pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 52 0]
test panedwindow-18.9 {MoveSash, move right respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -padx 5
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 50 0]
test panedwindow-18.10 {MoveSash, move right, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 0 50 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 50 0] [list 52 0]]
test panedwindow-18.11 {MoveSash, move left} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqwidth .p]
    
    .p sash place 0 10 0
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqwidth .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {10 0}]
test panedwindow-18.12 {MoveSash, move left, can't move outside of window} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 -100 0
    
    # Get the new sash coord; it should be clipped by the reqwidth of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 0]
test panedwindow-18.13 {MoveSash, move left respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 10 0]
test panedwindow-18.14 {MoveSash, move left respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 22 0]
test panedwindow-18.15 {MoveSash, move left pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 0]
test panedwindow-18.16 {MoveSash, move left pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 10 0]
test panedwindow-18.17 {MoveSash, move left respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -padx 5
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 42 0]
test panedwindow-18.18 {MoveSash, move left, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue green} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 1 10 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 8 0] [list 10 0]]

test panedwindow-19.1 {MoveSash, move down} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqheight .p]
    
    .p sash place 0 0 30
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqheight .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {0 30}]
test panedwindow-19.2 {MoveSash, move down (unmapped) clipped by reqheight} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should be clipped by the reqheight of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 40]
test panedwindow-19.3 {MoveSash, move down (mapped, height < reqheight) clipped by height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a height < reqheight
    place .p -x 0 -y 0 -height 32
    update

    .p sash place 0 0 100
    
    # Get the new sash coord; it should be clipped by the visible height of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 30]
test panedwindow-19.4 {MoveSash, move down (mapped, height > reqheight) clipped by height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a width > reqwidth
    place .p -x 0 -y 0 -height 102
    update

    .p sash place 0 0 200
    
    # Get the new sash coord; it should be clipped by the visible width of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 100]
test panedwindow-19.5 {MoveSash, move down respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 30]
test panedwindow-19.6 {MoveSash, move down respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 40]
test panedwindow-19.7 {MoveSash, move down pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 62]
test panedwindow-19.8 {MoveSash, move down pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 52]
test panedwindow-19.9 {MoveSash, move down respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -pady 5
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 50]
test panedwindow-19.10 {MoveSash, move right, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 0 0 50
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 0 50] [list 0 52]]
test panedwindow-19.11 {MoveSash, move up} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqheight .p]
    
    .p sash place 0 0 10
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqheight .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {0 10}]
test panedwindow-19.12 {MoveSash, move up, can't move outside of window} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 0 -100
    
    # Get the new sash coord; it should be clipped by the reqwidth of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 0]
test panedwindow-19.13 {MoveSash, move up respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 10]
test panedwindow-19.14 {MoveSash, move up respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 22]
test panedwindow-19.15 {MoveSash, move up pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 0]
test panedwindow-19.16 {MoveSash, move up pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 10]
test panedwindow-19.17 {MoveSash, move up respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -pady 5
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 42]
test panedwindow-19.18 {MoveSash, move up, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue green} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 1 0 10
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 0 8] [list 0 10]]

# The following tests check that the panedwindow is correctly computing its
# geometry based on the various configuration options that can affect the
# geometry.

test panedwindow-20.1 {ComputeGeometry, reqheight taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .f3 configure -height 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 20] [list 60 40]]
test panedwindow-20.2 {ComputeGeometry, reqheight taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -height 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 20] [list 60 40]]
test panedwindow-20.3 {ComputeGeometry, reqheight taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue] -pady 20
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -height 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 60] [list 60 80]]
test panedwindow-20.4 {ComputeGeometry, reqwidth taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .f3 configure -width 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 20 60] [list 40 60]]
test panedwindow-20.5 {ComputeGeometry, reqwidth taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -width 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 20 60] [list 40 60]]
test panedwindow-20.6 {ComputeGeometry, reqwidth taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue] -padx 20
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -width 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 60] [list 80 60]]

set i 6
foreach bd {0 2} {
    foreach sp {0 5} {
	foreach sw {0 3} {
	    foreach h {0 1} {
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, one slave, reqsize set properly} {
		    # With just one slave, sashpad and sashwidth should not
		    # affect the panedwindow's geometry, since no sash should
		    # ever be drawn.
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    .p add [frame .p.f -width 20 -height 20 -bg red] -padx $h \
                            -sticky ""
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .p.f
		    set result
		} [list [expr {(2 * $bd) + 20 + (2 * $h)}] \
			[expr {(2 * $bd) + 20}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, three panes, reqsize set properly} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    foreach w {.p.f1 .p.f2 .p.f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .p.f1 .p.f2 .p.f3
		    set result
		} [list [expr {(2 * $bd) + ($h?12:(2*$sw)) + (4*$sp) + 60}] \
			[expr {(2 * $bd) + 20}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, sash coords} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    foreach w {.f1 .f2 .f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [.p sash coord 0] [.p sash coord 1]]
		    destroy .p .f1 .f2 .f3
		    set result
		} [list [list [expr {$bd+20+($h?(6-$sw)/2:0)+$sp}] $bd] \
			[list [expr {$bd+40+($h?6+(6-$sw)/2:$sw)+(3*$sp)}] \
			    $bd]]

		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry/ArrangePanes, slave coords} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    foreach w {.p.f1 .p.f2 .p.f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
				-sticky nsew -pady 3 -padx 11
		    }
		    pack .p
		    update
		    set result {}
		    foreach w {.p.f1 .p.f2 .p.f3} {
			lappend result [list [winfo x $w] [winfo y $w] \
				[winfo width $w] [winfo height $w]]
		    }
		    destroy .p .p.f1 .p.f2 .p.f3
		    set result
		} [list [list [expr {$bd+11}] [expr {$bd+3}] 20 20] \
			[list [expr {$bd+53+($h?6:$sw)+(2*$sp)}] \
			    [expr {$bd+3}] 20 20] \
			[list [expr {$bd+95+($h?12:2*$sw)+(4*$sp)}] \
			    [expr {$bd+3}] 20 20]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, one slave, vertical} {
		    # With just one slave, sashpad and sashwidth should not
		    # affect the panedwindow's geometry, since no sash should
		    # ever be drawn.
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -orient vertical -sashwidth $sw -handlesize 6 \
			    -showhandle $h
		    .p add [frame .f -width 20 -height 20 -bg red] -pady $h \
                            -sticky ""
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .f
		    set result
		} [list [expr {(2 * $bd) + 20}] \
			[expr {(2 * $bd) + 20 + (2 * $h)}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, three panes, vertical} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h \
			    -orient vertical
		    foreach w {.f1 .f2 .f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .f1 .f2 .f3
		    set result
		} [list [expr {(2 * $bd) + 20}] \
			[expr {(2 * $bd) + ($h?12:(2*$sw)) + (4*$sp) + 60}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, sash coords, vertical} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h \
			    -orient vertical
		    foreach w {.f1 .f2 .f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [.p sash coord 0] [.p sash coord 1]]
		    destroy .p .f1 .f2 .f3
		    set result
		} [list [list $bd [expr {$bd+20+($h?(6-$sw)/2:0)+$sp}]] \
			[list $bd \
			    [expr {$bd+40+($h?6+(6-$sw)/2:$sw)+(3*$sp)}]]]

		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry/ArrangePanes, slave coords, vert} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h \
			    -orient vertical
		    foreach w {.p.f1 .p.f2 .p.f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
				-sticky nsew -pady 11 -padx 3
		    }
		    pack .p
		    update
		    set result {}
		    foreach w {.p.f1 .p.f2 .p.f3} {
			lappend result [list [winfo x $w] [winfo y $w] \
				[winfo width $w] [winfo height $w]]
		    }
		    destroy .p .p.f1 .p.f2 .p.f3
		    set result
		} [list [list [expr {$bd+3}] [expr {$bd+11}] 20 20] \
			[list [expr {$bd+3}] \
			    [expr {$bd+53+($h?6:$sw)+(2*$sp)}] 20 20] \
			[list [expr {$bd+3}] \
			    [expr {$bd+95+($h?12:2*$sw)+(4*$sp)}] 20 20]]
	    }
	}
    }
}

test panedwindow-21.1 {destroyed widgets are removed from panedwindow} {
    panedwindow .p
    .p add [frame .f -width 20 -height 20 -bg blue]
    destroy .f
    set result [.p panes]
    destroy .p
    set result
} {}
test panedwindow-21.2 {destroyed slave causes geometry recomputation} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red]
    destroy .f
    set result [winfo reqwidth .p]
    destroy .p .f2
    set result
} 20
    
test panedwindow-22.1 {ArrangePanes, extra space is given to the last pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky nsew
    place .p -width 100 -x 0 -y 0
    update
    set result [winfo width .f2]
    destroy .p .f1 .f2
    set result
} 78
test panedwindow-22.2 {ArrangePanes, extra space is given to the last pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky nsew
    place .p -height 100 -x 0 -y 0
    update
    set result [winfo height .f2]
    destroy .p .f1 .f2
    set result
} 78
test panedwindow-22.3 {ArrangePanes, explicit height/width are preferred} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky ""
    .p paneconfigure .f1 -width 10 -height 15
    pack .p
    update
    set result [list [winfo width .f1] [winfo height .f1]]
    destroy .p .f1 .f2
    set result
} {10 15}
test panedwindow-22.4 {ArrangePanes, panes clipped by size of pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red]
    .p sash place 0 10 0
    pack .p
    update
    set result [list [winfo width .f1] [winfo height .f1]]
    destroy .p .f1 .f2
    set result
} {10 20}
test panedwindow-22.5 {ArrangePanes, panes clipped by size of pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red]
    .p sash place 0 0 10
    pack .p
    update
    set result [list [winfo width .f1] [winfo height .f1]]
    destroy .p .f1 .f2
    set result
} {20 10}
test panedwindow-22.6 {ArrangePanes, height of pane taken from total height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 20 -height 40 -bg red] -sticky ""
    pack .p
    update
    set result [list [winfo y .p.f1]]
    destroy .p .p.f1 .p.f2
    set result
} 10
test panedwindow-22.8 {ArrangePanes, width of pane taken from total width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 40 -height 40 -bg red] -sticky ""
    pack .p
    update
    set result [list [winfo x .p.f1]]
    destroy .p .p.f1 .p.f2
    set result
} 10
test panedwindow-22.9 {ArrangePanes, panes with width <= 0 are unmapped} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 40 -bg red]
    pack .p
    update
    set result [winfo ismapped .f1]
    .p sash place 0 0 0
    update
    lappend result [winfo ismapped .f1]
    destroy .p .f1 .f2
    set result
} {1 0}
test panedwindow-22.10 {ArrangePanes, panes with width <= 0 are unmapped} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 20 -height 40 -bg red]
    pack .p
    update
    set result [winfo ismapped .p.f1]
    .p sash place 0 0 0
    update
    lappend result [winfo ismapped .p.f1]
    destroy .p .p.f1 .p.f2
    set result
} {1 0}
test panedwindow-22.11 {ArrangePanes, panes with width <= 0 are unmapped} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 -orient vertical
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 20 -height 40 -bg red]
    pack .p
    update
    set result [winfo ismapped .p.f1]
    .p sash place 0 0 0
    update
    lappend result [winfo ismapped .p.f1]
    destroy .p .p.f1 .p.f2
    set result
} {1 0}
    
test panedwindow-23.1 {PanedWindowReqProc, react to slave geometry changes} {
    # Basically just want to make sure that the PanedWindowReqProc is called
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 40 -bg red]
    set result [winfo reqheight .p]
    .f1 configure -height 80
    lappend result [winfo reqheight .p]
    destroy .p .f1 .f2
    set result
} {40 80}

test panedwindow-24.1 {ConfigurePanes, can't add panedwindow to itself} {
    panedwindow .p
    set result [list [catch {.p add .p} msg] $msg]
    destroy .p
    set result
} [list 1 "can't add .p to itself"]
test panedwindow-24.2 {ConfigurePanes, bad window throws error} {
    panedwindow .p
    set result [list [catch {.p add .b} msg] $msg]
    destroy .p
    set result
} [list 1 "bad window path name \".b\""]
test panedwindow-24.3 {ConfigurePanes, bad window aborts processing} {
    panedwindow .p
    button .b
    catch {.p add .b .a}
    set result [.p panes]
    destroy .p .b
    set result
} {}
test panedwindow-24.4 {ConfigurePanes, bad option aborts processing} {
    panedwindow .p
    button .b
    catch {.p add .b -sticky foobar}
    set result [.p panes]
    destroy .p .b
    set result
} {}
test panedwindow-24.5 {ConfigurePanes, after win isn't managed by panedwin} {
    panedwindow .p
    button .b
    button .c
    set result [list [catch {.p add .b -after .c} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "window \".c\" is not managed by .p"]
test panedwindow-24.6 {ConfigurePanes, before win isn't managed by panedwin} {
    panedwindow .p
    button .b
    button .c
    set result [list [catch {.p add .b -before .c} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "window \".c\" is not managed by .p"]
test panedwindow-24.7 {ConfigurePanes, -after {} is a no-op} {
    panedwindow .p
    .p add [button .b] [button .c]
    .p paneconfigure .b -after {}
    set result [.p panes]
    destroy .p .b .c
    set result
} {.b .c}
test panedwindow-24.8 {ConfigurePanes, -before {} is a no-op} {
    panedwindow .p
    .p add [button .b] [button .c]
    .p paneconfigure .b -before {}
    set result [.p panes]
    destroy .p .b .c
    set result
} {.b .c}
test panedwindow-24.9 {ConfigurePanes, new panes are added} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [.p panes]
    destroy .p .b .c
    set result
} {.b .c}
test panedwindow-24.10 {ConfigurePanes, options applied to all panes} {
    panedwindow .p
    .p add [button .b] [button .c] -sticky ne -height 5 -width 5 -minsize 10
    set result {}
    foreach w {.b .c} {
	set val {}
	foreach option {-sticky -height -width -minsize} {
	    lappend val $option [.p panecget $w $option]
	}
	lappend result $w $val
    }
    destroy .p .b .c
    set result
} [list .b {-sticky ne -height 5 -width 5 -minsize 10} \
	.c {-sticky ne -height 5 -width 5 -minsize 10}]
test panedwindow-24.11 {ConfigurePanes, existing panes are reconfigured} {
    panedwindow .p
    .p add [button .b] -sticky nw -height 10
    .p add .b [button .c] -sticky se -height 2
    set result [list [.p panes] \
	    [.p panecget .b -sticky] [.p panecget .b -height] \
	    [.p panecget .c -sticky] [.p panecget .c -height]]
    destroy .p .b .c
    set result
} [list {.b .c} es 2 es 2]
test panedwindow-24.12 {ConfigurePanes, widgets added to end by default} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    .p add [button .d]
    set result [.p panes]
    destroy .p .b .c .d
    set result
} {.b .c .d}
test panedwindow-24.13 {ConfigurePanes, -after, single addition} {
    panedwindow .p
    button .a
    button .b
    button .c

    .p add .a .b
    .p add .c -after .a
    set result [.p panes]
    destroy .p .a .b .c
    set result
} {.a .c .b}
test panedwindow-24.14 {ConfigurePanes, -after, multiple additions} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b
    .p add .c .d -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .c .d .b}
test panedwindow-24.15 {ConfigurePanes, -after, relocates existing widget} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .d -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .d .b .c}
test panedwindow-24.16 {ConfigurePanes, -after, relocates existing widgets} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .b .d -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .b .d .c}
test panedwindow-24.17 {ConfigurePanes, -after, relocates existing widgets} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .d .a -after .b
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.b .d .a .c}
test panedwindow-24.18 {ConfigurePanes, -after, relocates existing widgets} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .d .a -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.d .a .b .c}
test panedwindow-24.19 {ConfigurePanes, -after, after last window} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c
    .p add .d -after .c
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .b .c .d}
test panedwindow-24.20 {ConfigurePanes, -before, before first window} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c
    .p add .d -before .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.d .a .b .c}
test panedwindow-24.21 {ConfigurePanes, -before, relocate existing windows} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c
    .p add .d .b -before .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.d .b .a .c}
test panedwindow-24.22 {ConfigurePanes, slave specified multiple times} {
    # This test should not cause a core dump

    panedwindow .p
    button .a
    button .b
    button .c

    .p add .a .a .b .c
    set result [.p panes]
    destroy .p .a .b .c
    set result
} {.a .b .c}
test panedwindow-22.23 {ConfigurePanes, slave specified multiple times} {
    # This test should not cause a core dump

    panedwindow .p
    button .a
    button .b
    button .c

    .p add .a .a .b .c
    .p add .a .b .a -after .c
    set result [.p panes]
    destroy .p .a .b .c
    set result
} {.c .a .b}
test panedwindow-22.24 {ConfigurePanes, panedwindow cannot manage toplevels} {
    panedwindow .p
    toplevel .t
    set result [list [catch {.p add .t} msg] $msg]
    destroy .p .t
    set result
} [list 1 "can't add toplevel .t to .p"]
test panedwindow-22.25 {ConfigurePanes, restrict possible panes} {
    panedwindow .p
    frame .f
    button .f.b
    set result [list [catch {.p add .f.b} msg] $msg]
    destroy .p .f .f.b
    set result
} [list 1 "can't add .f.b to .p"]
test panedwindow-22.26 {ConfigurePanes, restrict possible panes} {
    frame .f
    panedwindow .f.p
    button .b
    set result [list [catch {.f.p add .b} msg] $msg]
    destroy .f.p .f .b
    set result
} [list 0 ""]
test panedwindow-22.27 {ConfigurePanes, restrict possible panes} {
    panedwindow .p
    button .p.b
    set result [list [catch {.p add .p.b} msg] $msg]
    destroy .p .p.b
    set result
} [list 0 ""]
test panedwindow-22.28 {ConfigurePanes, restrict possible panes} {
    frame .f
    frame .f.f
    frame .f.f.f
    panedwindow .f.f.f.p
    button .b
    set result [list [catch {.f.f.f.p add .b} msg] $msg]
    destroy .f .f.f .f.f.f .f.f.f.p .b
    set result
} [list 0 ""]

test panedwindow-26.1 {DestroyPanedWindow} {
    # This test should not result in any memory leaks.
    panedwindow .p
    foreach w {.a .b .c .d .e .f .g .h .i .j .k .l .m .n .o .q .r .s .t} {
	.p add [button $w]
    }
    foreach w {.a .b .c .d .e .f .g .h .i .j .k .l .m .n .o .p .q .r .s .t} {
	destroy $w
    }
    set result {}
} {}

test panedwindow-27.1 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 0]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.2 {PanedWindowIdentifyCoords, padding is included} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 20 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.3 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 22 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.4 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 24 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.5 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 26 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.6 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 26 -1]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.7 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 26 100]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.8 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 22 4]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.9 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 22 5]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.10 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 20 5]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.11 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 20 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.12 {PanedWindowIdentifyCoords} {
    panedwindow .p -showhandle false -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20] \
	    [frame .f3 -bg green -width 20 -height 20]
    set result [.p identify 48 0]
    destroy .p .f .f2 .f3
    set result
} {1 sash}
test panedwindow-27.13 {identify subcommand errors} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4
    set result [list [catch {.p identify} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p identify x y\""]
test panedwindow-27.14 {identify subcommand errors} {
    panedwindow .p
    set result [list [catch {.p identify foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-27.14 {identify subcommand errors} {
    panedwindow .p
    set result [list [catch {.p identify 0 bar} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"bar\""]
test panedwindow-27.15 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 0]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.16 {PanedWindowIdentifyCoords, padding is included} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 20]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.17 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 22]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.18 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 24]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.19 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 26]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.20 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify -1 26]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.21 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 100 26]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.22 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 4 22]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.23 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 5 22]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.24 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 5 20]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.25 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 20]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.26 {PanedWindowIdentifyCoords} {
    panedwindow .p -showhandle false -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20] \
	    [frame .f3 -bg green -width 20 -height 20]
    set result [.p identify 0 48]
    destroy .p .f .f2 .f3
    set result
} {1 sash}
    
    
# cleanup
::tcltest::cleanupTests
return
