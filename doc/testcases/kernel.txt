device-drivers
--------------
ltpacpi.sh

	ACPI (Advanced Control Power & Integration) testscript for 2.5 kernels.


fs
--
doio

	growfiles

		This program will grow a list of files.
		Each file will grow by grow_incr before the same
		file grows twice.  Each file is open and closed before next file is opened.

	rwtest

		A wrapper for doio and iogen.

		doio -  a general purpose io initiator with system call and
                	write logging.  See doio.h for the structure which defines
	                what doio requests should look like.
  
	                Currently doio can handle read,write,reada,writea,ssread,
	                sswrite, and many varieties of listio requests.
        	        For disk io, if the O_SSD flag is set doio will allocate
	                the appropriate amount of ssd and do the transfer - thus, doio
	                can handle all of the primitive types of file io.

		iogen - a tool for generating file/sds io for a doio process

fs_di
	A FileSystem Data Integrity test.

fs_inod

	Rapidly creates and deletes files through
        multiple processes running in the background.
        The user may specify the number of subdirectories
        to create, the number of files to create (per
        subdirectory), and the number of times to repeat
        the creation/deletion cycle.

fs_maim

	Collection of smaller scripts to stress storage management
	utilities.

fs_perms

	Regression test for Linux filesystem permissions.

fsstress

	A highly configurable stress test utility that calls most of the main
	file system syscalls.  Originally developed by SGI for XFS testing.

fsx-linux
	
	Filesystem stress test developed by Apple Computer, Inc.

ftest

	A collection of file system tests developed by Sequent/IBM.

inode

	Inode-based stress tests.

lftest
	The purpose of this test is to verify the file size limitations of a filesystem.
        It writes one buffer at a time and lseeks from the beginning of the file to the
        end of the last write position.  The intent is to test lseek64.

linktest

	Regression test for max links per file

openfile

	Creates files and opens simultaneously

proc
	
	Recursively reads all files within /proc filesystem.

stream

	Collection of tests for testing stream functions.



io
--
aio

	Collection of asynchronous i/o tests.


direct_io

	Collection of direct i/o tests.

disktest

        Does repeated accesses to a filespec and optionally writes to, reads from,
        and  verifies  the  data.  By default, disktest makes assumptions about 
        the running environment which allows for a quick start of IO generation.  
	However, Disktest has  a  large  number  of command line options which can 
        be used to adapt the test for a variety of uses including data integrity, 
	medium integraty, performance, and  simple application simulation.


stress_cd

	Creates multiple read threads on the cdrom device.

stress_floppy

	Tests the reading/writing/formatting on a floppy drive.



ipc
---
ipc_stress

	A collection of tests designed to stress IPC.

pipeio

	This tool can be used to beat on system or named pipes.
	See the help() function below for user information.

semaphore

	sem01

		Creates a semaphore and two processes.  The processes
        	each go through a loop where they semdown, delay for a
      		random amount of time, and semup, so they will almost
        	always be fighting for control of the semaphore.

	sem02
		The application creates several threads using pthread_create().
		One thread performs a semop() with the SEM_UNDO flag set. The
		change in sempaphore value performed by that semop should be
		"undone" only when the last pthread exits.



mem
---
libmm

	Tests the libmm core API.

mem

	mem01

		Test for exercising virtual memory allocation
	        and usage. It is intended to provide a limited exposure of the
	        system swapper, for now.

	mem02

		Checks that memory can be allocated and freed.

mmapstress

	A group of tests for testing mmap().

mtest01

        mallocs memory <chunksize> at a time until malloc fails.

mtest05

	mmstress

		Performs General Stress with Race conditions

mtest06

	mmap1

		Test the LINUX memory manager. The program is aimed at        
	        stressing the memory manager by simultanious map/unmap/read   
	        by light weight processes, the test is scheduled to run for   
	        a mininum of 24 hours.

	mmap2

		Test the LINUX memory manager. The program is aimed at       
	        stressing the memory manager by repeaded map/write/unmap of a 
	        of a large gb size file.     

	mmap3

		Test the LINUX memory manager. The program is aimed at        
		stressing the memory manager by repeaded map/write/unmap      
		of file/memory of random size (maximum 1GB) this is done by
		multiple processes.	 

	shmat1

		Test the LINUX memory manager. The program is aimed at      
		stressing the memory manager by repeaded shmat/write/read/    
		shmatd of file/memory of random size (maximum 1000 * 4096)    
		done by multiple processes.  

mtest07

	mallocstress

		Stresses the VMM and C library by spawning N threads which
		malloc blocks of increasing size until malloc returns NULL.

	shm_test

		Stresses memory management subsystem of Linux. Spawns multiple
		pairs of reader & writer threads. One thread will create the
		shared segment of random size and write to this memory, the 
		other pair will read from this memory.

page

	Tests the behavior of memory paging.

shmt

	A collection of shared memory tests.

vmtests

	Data and stack space VM tests.



module
------
create_module

	Tests the basic functionality of create_module().

delete_module

	Tests the basic functionality of delete_module().

query_module

	Tests the basic functionality of query_module().



pty
---
hangup01

	Writes three messages to a slave pty, with a hangup after each.
	Verifies all thre messages are received.

ptem01

	- Tests termio/termios ioctls
	- Tests window size setting and getting
	- Tests sending a break
	- Tests multiple opens of slave side
	- Tests several simultaneous opens
	
pty01

	- Tests slave locking
	- Tests slave operations with closed master
	- Tests operations on master with closed slave
	- Tests multiple opens on slave side of pty
	- Tests opening/closing of lots of ptys in parallel.



sched
-----
clisrv

	Read contents of data file. Write each line to socket, then   
	read line back from socket and write to standard output. 

hyperthreading

	ht_enabled

	        Test for whether HT enabling is the default setting and
	        the kernel option works as expected.

	ht_affinity

	        Test for whether a set of system calls is provided to bind
	        itself or another process to a subset of currently active
	        processors and to get affinity information.

	ht_interrupt
	        Test for SMP interrupt distribution among all logical CPU
	        should not be interfered by HT patch.

process_stress

	Stresses the process management kernel code.

pthreads

	pth_str01

		Creates a tree of threads

	pth_str02

		Creates n threads

	pth_str03
	
		Creates a tree of threads does calculations, and
	        returns result to parent

sched_stress

	Stress the scheduler code of the kernel.

tool

	time-schedule

		Tool to test how long a context switch takes.

	trace_sched

		This utility spawns N tasks, each task sets its priority by   
                making a system call to the scheduler. The thread function    
                reads the priority that tbe schedular sets for this task and  
                also reads from /proc the processor this task last executed on
                the information that is gathered by the thread function may   
                be in real-time. Its only an approximation.



syscalls
--------
  abort01

   Basic test for abort(3).


  accept01  
  
   Verify that accept() returns the proper errno for various failure cases

  
  access01

   Basic test for access(2) using F_OK, R_OK, W_OK, and X_OK  arguments.

  access02  
  
   Verify that access() succeeds to check the read/write/execute permissions
   on a file if the mode argument passed was R_OK/W_OK/X_OK.
 
   Also verify that, access() succeeds to test the accessibility of the file
   referred to by symbolic link if the pathname points to a symbolic link.
 
  access03

    EFAULT error testing for access(2).

  access04  
  
   Verify that,
    1. access() fails with -1 return value and sets errno to EACCES
       if the permission bits of the file mode do not permit the
 	 requested (Read/Write/Execute) access.
    2. access() fails with -1 return value and sets errno to EINVAL
 	if the specified access mode argument is invalid.
    3. access() fails with -1 return value and sets errno to EFAULT
 	if the pathname points outside allocate address space for the
 	process.
    4. access() fails with -1 return value and sets errno to ENOENT
 	if the specified file doesn't exist (or pathname is NULL).
    5. access() fails with -1 return value and sets errno to ENAMETOOLONG
       if the pathname size is > PATH_MAX characters.

  access05  
  
   Verify that access() succeeds to check the existance of a file if
   search access is permitted on the pathname of the specified file.


  acct01

   Issues calls to acct() and tests the returned values against expected
   results

  acct02

   Issues calls to acct() and tests the returned values against expected
   results
   

  adjtimex01

   Basic test for adjtimex().

  adjtimex02

   Tests for error conditions.


  alarm01	 	

   Basic test for alarm(2). 

  alarm02

   Boundary Value Test for alarm(2).

  alarm03

   Alarm(2) cleared by a fork.

  alarm04  
  
   Check that when an alarm request is made, the signal SIGALRM is received
   even after the process has done an exec().

  alarm05  
  
   Check the functionality of the Alarm system call when the time input
   parameter is non zero.

  alarm06  
  
   Check the functionality of the Alarm system call when the time input
   parameter is zero.
 
  alarm07  
  
   Check the functionality of the alarm() when the time input
   parameter is non-zero and the process does a fork.
   

  asyncio02

   Write/close flushes data to the file.


  bind01  
  
   Verify that bind() returns the proper errno for various failure cases
 

  brk01  
  
 	Test the basic functionality of brk().

  
  capget01

 	Test the basic functionality of capget().

  capget02

 	Test the error conditions of capget().
	

  capset01

 	Test the basic functionality of capset().

  capset02

 	Test the error conditions of capset().

	
  chdir01  
  
 	Check proper operation of chdir(): tests whether the
 	system call can it change the current, working directory, and find a
 	file there? Will it fail on a non-directory entry ?
 
  chdir02	 	

	Basic test for chdir(2).
 
  chdir03  
  
 	Testcase for testing that chdir(2) sets EACCES errno
 
  chdir04  
  
 	Testcase to test whether chdir(2) sets errno correctly.
  

  chmod01  
  
   Verify that, chmod(2) succeeds when used to change the mode permissions
   of a file. 

  chmod02

    Basic test for chmod(2).
 	
  chmod03  
  
   Verify that, chmod(2) will succeed to change the mode of a file
   and set the sticky bit on it if invoked by non-root (uid != 0)
   process with the following constraints,
 	- the process is the owner of the file.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is equal to the group ID of the file.
 	
  chmod04  
  
   Verify that, chmod(2) will succeed to change the mode of a directory
   and set the sticky bit on it if invoked by non-root (uid != 0) process
   with the following constraints,
 	- the process is the owner of the directory.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is equal to the group ID of the directory.
 	
  chmod05  
  
   Verify that, chmod(2) will succeed to change the mode of a directory
   but fails to set the setgid bit on it if invoked by non-root (uid != 0)
   process with the following constraints,
 	- the process is the owner of the directory.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is not equal to the group ID of the directory.
 
  chmod06  
  
    Verify that,
    1) chmod(2) returns -1 and sets errno to EPERM if the effective user id
 	of process does not match the owner of the file and the process is
 	not super user.
    2) chmod(2) returns -1 and sets errno to EACCES if search permission is
 	denied on a component of the path prefix.
    3) chmod(2) returns -1 and sets errno to EFAULT if pathname points
 	outside user's accessible address space.
    4) chmod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
 	component is too long.
    5) chmod(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname is not a directory.
    6) chmod(2) returns -1 and sets errno to ENOENT if the specified file
 	does not exists.

  chmod07  
  
   Verify that, chmod(2) will succeed to change the mode of a file/directory
   and sets the sticky bit on it if invoked by root (uid = 0) process with
   the following constraints,
 	- the process is not the owner of the file/directory.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is equal to the group ID of the file/directory.

 
  chown01

   Basic test for chown(2).
  
  chown02  
  
   Verify that, when chown(2) invoked by super-user to change the owner and
   group of a file specified by path to any numeric owner(uid)/group(gid)
   values,
 	- clears setuid and setgid bits set on an executable file.
 	- preserves setgid bit set on a non-group-executable file.
 
  chown03  
  
   Verify that, chown(2) succeeds to change the group of a file specified
   by path when called by non-root user with the following constraints,
 	- euid of the process is equal to the owner of the file.	 
 	- the intended gid is either egid, or one of the supplementary gids
 	  of the process.
   Also, verify that chown() clears the setuid/setgid bits set on the file.
 
  chown04  
  
    Verify that,
    1) chown(2) returns -1 and sets errno to EPERM if the effective user id
 	of process does not match the owner of the file and the process is
 	not super user.
    2) chown(2) returns -1 and sets errno to EACCES if search permission is
 	denied on a component of the path prefix.
    3) chown(2) returns -1 and sets errno to EFAULT if pathname points
 	outside user's accessible address space.
    4) chown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
 	component is too long.
    5) chown(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname is not a directory.
    6) chown(2) returns -1 and sets errno to ENOENT if the specified file
 	does not exists.

  chown05  
  
   Verify that, chown(2) succeeds to change the owner and group of a file
   specified by path to any numeric owner(uid)/group(gid) values when invoked 
   by super-user.


  chroot01  
  
   Testcase to check the whether chroot sets errno to EPERM.
 
  chroot02  
  
   Test functionality of chroot(2)
 	
  chroot03  
  
   Testcase to test whether chroot(2) sets errno correctly.

  
  clone01

   Basic test for clone(2)

  clone02

   Functionality tests for clone(2)

  clone03

   Test for clone(2)

  clone04

   Test for checking error conditions for clone(2)

  clone05

   Test for CLONE_VFORK flag

  clone06

   Test to verify inheritance of environment variables.

 
  close01  
  
   Test that closing a regular file and a pipe works correctly
 
  close02  
  
    Check that an invalid file descriptor returns EBADF

  close08
	
    Basic test for close(2).


  confstr01

    Basic test for confstr().

 
  connect01  
  
   Verify that connect() returns the proper errno for various failure cases
 

  creat01  
  
   Testcase to check the basic functionality of the creat(2) system call.
 
  creat03  
  
   Testcase to check whether the sticky bit cleared.
 
  creat04  
  
   Testcase to check creat(2) fails with EACCES
 
  creat05  
  
   Testcase to check that creat(2) system call returns EMFILE.
 
  creat06  
  
   Testcase to check creat(2) sets the following errnos correctly:
 	1.	EISDIR
 	2.	ENAMETOOLONG
 	3.	ENOENT
 	4.	ENOTDIR
 	5.	EFAULT
 	6.	EACCES
 
  creat07  
  
   Testcase to check creat(2) sets the following errnos correctly:
 	1.	ETXTBSY

  creat08

   Verifies that the group ID and setgid bit are set correctly when
   a new file is created.

  creat09

   Basic test for creat(2) using 0700 argument.

  dup01		

   Basic test for dup(2).

  dup02		 	
   
   Negative test for dup(2) with bad fd.

  dup03
   
   Negative test for dup(2) (too many fds).

  dup04
   
   Basic test for dup(2) of a system pipe descriptor.

  dup05

   Basic test for dup(2) of a named pipe descriptor. 

  dup06

   Test if dup returns -1 on the 21st file when _NFILE is 20.

  dup07

   Test if the access mode is the same for both file descriptors.


  dup201  
  
 	Negative tests for dup2() with bad fd (EBADF), and for "too many
 	open files" (EMFILE)
  
  dup202  
  
 	Is the access mode the same for both file descriptors?
 		0: read only ?	"0444"
 		1: write only ? "0222"
 		2: read/write ? "0666"
 
  dup203  
  
 	Testcase to check the basic functionality of dup2().
 
  dup204  
  
 	Testcase to check the basic functionality of dup2(2).

  dup205

	Testcase to check if -1 is returned on the 21st file when _NFILE is 20.


  execl01

	Basic test for execl(2).


  execle01

	Basic test for execle(2). 


  execlp01

	Basic test for execlp(2). 


  execv01

	Basic test for execv(2).  


  execve01

	Basic test for execve(2).

  execve02  
  
 	Testcase to check whether execve(2) sets errno to EACCES correctly
 
  execve03  
  
 	Testcase to check execve sets the following errnos correctly:
 	1.	ENAMETOOLONG
 	2.	ENOENT
 	3.	ENOTDIR
 	4.	EFAULT
 	5.	EACCES
 	6.	ENOEXEC
  
  execve04  
  
 	Testcase to check execve(2) sets errno to EMFILE correctly
 
  execve05  
  
 	Testcase to check execve sets the following errnos correctly:
 	1.	ETXTBSY

  execve06  
  
  	This testcase tests the basic functionality of the execve(2) system
 	call.


  execvp01

	Basic test for execvp(2) 

  
  exit01  
  
 	Check that exit returns the correct values to the waiting parent
 
  exit02  
  
 	Check that exit flushes output file buffers and closes files upon
 	exitting

 
  fchdir01  
  
 	fchdir01 - create a directory and cd into it.
 
  fchdir02  
  
 	fchdir02 - try to cd into a bad directory (bad fd).
 
  
  fchmod01

	Basic test for Fchmod(2).

  fchmod02  
  
   Verify that, fchmod(2) will succeed to change the mode of a file/directory
   set the sticky bit on it if invoked by root (uid = 0) process with
   the following constraints,
 	- the process is not the owner of the file/directory.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is equal to the group ID of the file/directory.
 	
  fchmod03  
  
   Verify that, fchmod(2) will succeed to change the mode of a file
   and set the sticky bit on it if invoked by non-root (uid != 0)
   process with the following constraints,
 	- the process is the owner of the file.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is equal to the group ID of the file.
 	
  fchmod04  
  
   Verify that, fchmod(2) will succeed to change the mode of a directory
   and set the sticky bit on it if invoked by non-root (uid != 0) process
   with the following constraints,
 	- the process is the owner of the directory.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is equal to the group ID of the directory.
 	
  fchmod05  
  
   Verify that, fchmod(2) will succeed to change the mode of a directory
   but fails to set the setgid bit on it if invoked by non-root (uid != 0)
   process with the following constraints,
 	- the process is the owner of the directory.
 	- the effective group ID or one of the supplementary group ID's of the
 	  process is not equal to the group ID of the directory.
 
  fchmod06  
  
    Verify that,
    1) fchmod(2) returns -1 and sets errno to EPERM if the effective user id
 	of process does not match the owner of the file and the process is
 	not super user.
    2) fchmod(2) returns -1 and sets errno to EBADF if the file descriptor
 	of the specified file is not valid.
 
  fchmod07  
  
   Verify that, fchmod(2) succeeds when used to change the mode permissions
   of a file specified by file descriptor. 


  fchown01

	Basic test for fchown(2).

  fchown02  
  
   Verify that, when fchown(2) invoked by super-user to change the owner and
   group of a file specified by file descriptor to any numeric 
   owner(uid)/group(gid) values,
 	- clears setuid and setgid bits set on an executable file.
 	- preserves setgid bit set on a non-group-executable file.
 
  fchown03  
  
   Verify that, fchown(2) succeeds to change the group of a file specified
   by path when called by non-root user with the following constraints,
 	- euid of the process is equal to the owner of the file.	 
 	- the intended gid is either egid, or one of the supplementary gids
 	  of the process.
   Also, verify that fchown() clears the setuid/setgid bits set on the file.
 
  fchown04  
  
    Verify that,
    1) fchown(2) returns -1 and sets errno to EPERM if the effective user id
 	of process does not match the owner of the file and the process is
 	not super user.
    2) fchown(2) returns -1 and sets errno to EBADF if the file descriptor
 	of the specified file is not valid.

  fchown05  
  
   Verify that, fchown(2) succeeds to change the owner and group of a file
   specified by file descriptor to any numeric owner(uid)/group(gid) values 
   when invoked by super-user.
 

  fcntl01  
  
  	Test F_DUPFD, F_SETFL cmds of fcntl

  fcntl02

	Basic test for fcntl(2) using F_DUPFD argument.

  fcntl03

	Basic test for fcntl(2) using F_GETFD argument.

  fcntl04

	Basic test for fcntl(2) using F_GETFL argument. 

  fcntl05

	Basic test for fcntl(2) using F_GETLK argument. 

  fcntl06  
  
  	Error checking conditions for remote locking of regions of a file.

  fcntl07

	Close-On-Exec functional test. 

  fcntl07B

	Close-On-Exec of named pipe functional test. 

  fcntl08

	Basic test for fcntl(2) using F_SETFL argument. 

  fcntl09

	Basic test for fcntl(2) using F_SETLK argument. 

  fcntl10

	Basic test for fcntl(2) using F_SETLKW argument. 

  fcntl11  
  
  	Testcase to check locking of regions of a file
 
  fcntl12  
  
 	Testcase to test that fcntl() sets EMFILE for F_DUPFD command.
 
  fcntl13  
  
 	Testcase to test that fcntl() sets errno correctly.

  fcntl14  
  
  	File locking test cases for fcntl. In Linux, S_ENFMT is not implemented
 	in the kernel. However all standard Unix kernels define S_ENFMT as
 	S_ISGID. So this test defines S_ENFMT as S_ISGID.
 
  fcntl15  
  
  	Check that file locks are removed when file closed
 
  fcntl16  
  
  	Additional file locking test cases for checking proper notifictaion
  	of processes on lock change
 
  fcntl17  
  
  	Check deadlock detection for file locking
 
  fcntl18  
  
  	Test to check the error conditions in fcntl system call
 
  fcntl19  
  
  	Testcase to check locking of regions of a file
 
  fcntl20  
  
  	Check locking of regions of a file
 
  fcntl21  
  
  	Check locking of regions of a file
 

  fdatasync01

	Basic test for fdatasync(2).

  fdatasync02

	Checking error conditions for fdatasync(2).


  flock01

	Basic test for flock(2)

  flock02

	Error condition test for flock(2)

  flock03

	Error condition test for flock(2)

  flock04

	Testing different locks on flock(2)

  flock05

	Testing different locks on flock(2)

  flock06

	Error condition test for flock(2)
  

  fmtmsg01

	Basic test of fmtmsg().


  fork01

	Basic test for fork(2). 
  
  fork02  
  
 	Test correct operation of fork:
  		pid == 0 in child;
  		pid > 0 in parent from wait;
 
  fork03  
  
 	Check that child can use a large text space and do a large
 	number of operations.	
 
  fork04

	Child inheritance of Environment Variables after fork(). 

  fork05

	Make sure LDT is propagated correctly 

  fork06  
  
 	Test that a process can fork children a large number of
 	times in succession
 
  fork07  
  
 	Check that all children inherit parent's file descriptor
 
  fork08  
  
 	Check if the parent's file descriptors are affected by 
  	actions in the child; they should not be.

  fork09  
  
 	Check that child has access to a full set of files.
  
  fork10  
  
 	Check inheritance of file descriptor by children, they
  	should all be refering to the same file.
 
  fork11  
  
 	Test that parent gets a pid from each child when doing wait

  fork12

	Check that all children inherit parent's file descriptor


  fpathconf

	Basic test for fpathconf(2)


  fstat01

	Basic test for fstat(2)

  fstat02  
  
   Verify that, fstat(2) succeeds to get the status of a file and fills
   the stat structure elements though file pointed to by file descriptor
   not opened for reading.
 
  fstat03  
  
    Verify that, fstat(2) returns -1 and sets errno to EBADF if the file 
    pointed to by file descriptor is not valid.
 
  fstat04
  
   Verify that, fstat(2) succeeds to get the status of a file pointed by
   file descriptor and fills the stat structure elements.

  fstat05

   Verify that, if buffer points outside user's accessible address space
   fstat(2) either returns -1 and sets errno to EFAULT or
   SIGSEGV is returned instead of EFAULT.
 

  fstatfs01

	Basic test for fstatfs(2)

  fstatfs02  
  
 	Testcase to check fstatfs() sets errno correctly.
 

  fsync01

	Basic test for fsync(2) 
 
  fsync02  
  
 	Create a sparse file, fsync it, and time the fsync
 
  fsync03
  
 	Testcase to check that fsync(2) sets errno correctly.

 
  ftruncate01  
  
   Verify that, ftruncate(2) succeeds to truncate a file to a specified
   length if the file indicated by file descriptor opened for writing.
 
  ftruncate02  
  
   Verify that, ftruncate(2) succeeds to truncate a file to a certain length,
   but the attempt to read past the truncated length will fail.  
 
  ftruncate03  
  
   Verify that,
   1) ftruncate(2) returns -1 and sets errno to EINVAL if the specified
      truncate length is less than 0.
   2) ftruncate(2) returns -1 and sets errno to EBADF if the file descriptor
      of the specified file is not valid.

  ftruncate04

   Test ftruncate/truncate and mandatory record locking.

 
  getcwd01  
  
 	Testcase to test that getcwd(2) sets errno correctly.
 
  getcwd02  
  
 	Testcase to check the basic functionality of the getcwd(2) system call.
 
  getcwd03  
  
 	Testcase to check the basic functionality of the getcwd(2) system call
 	for symbolically linked directories.

 
  getdents01  
  
 	getdents01 - get a directory entry
 
  getdents02  
  
 	getdents02 - check that we get a failure with a bad file descriptor
 
  getdents03  
  
 	getdents03 - check for an EINVAL error
 
  getdents04  
  
 	getdents04 - check for an ENOTDIR error
 
  getdents05  
  
 	getdents05 - check that we get a failure with a bad dirp address.


  getdomainname01
	
	Basic test for getdomainname().

 
  getegid01

	Basic test for getegid(2) 


  geteuid01

	Basic test for geteuid(2) 


  getgid01

 	Basic test for getgid(2) 

  getgid02  
  
 	Testcase to check the basic functionality of getgid().
 
  getgid03  
  
 	Testcase to check the basic functionality of getegid().
 

  getgroups01

	Getgroups system call critical test 

  getgroups02

	Basic test for getgroups(2) 

  getgroups03  
  
   Verify that, getgroups() system call gets the supplementary group IDs
   of the calling process.
 
  getgroups04  
  
   Verify that,
    getgroups() fails with -1 and sets errno to EINVAL if the size
    argument value is -ve.


  gethostid01

	Basic test for gethostid(2) 


  gethostname01

	Basic test for gethostname(2) 
 

  getitimer01  
  
 	Check that a correct call to getitimer() succeeds
 
  getitimer02  
  
 	Check that a getitimer() call fails as expected
 	with an incorrect second argument.
  getitimer03  
  
 	Check that a getitimer() call fails as expected
 	with an incorrect first argument.

 
  getpeername01  
  
   Verify that getpeername() returns the proper errno for various failure cases

 
  getpgid01  
  
 	Testcase to check the basic functionality of getpgid().
 
  getpgid02  
  
 	Testcase to check the basic functionality of getpgid().


  getpgrp01

 	Basic test for getpgrp(2)


  getpid01

	Basic test for getpid(2) 


  getpid02  
  
   Verify that getpid() system call gets the process ID of the of the
   calling process.
 
 
  getppid01  
  
  	Testcase to check the basic functionality of the getppid() syscall.
 

  getpriority01  
  
   Verify that getpriority() succeeds get the scheduling priority of 
   the current process, process group or user.
 
 
  getpriority02  
  
   Verify that,
    1) getpriority() sets errno to ESRCH  if no process was located
 	was located for 'which' and 'who' arguments.
    2) getpriority() sets errno to EINVAL if 'which' argument was
       not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.

 
  getresgid01  
  
   Verify that getresgid() will be successful to get the real, effective
   and saved user id of the calling process.
 
  getresgid02  
  
   Verify that getresgid() will be successful to get the real, effective
   and saved user ids after calling process invokes setregid() to change
   the effective/saved gids to that of specified user.
 
  getresgid03  
  
   Verify that getresgid() will be successful to get the real, effective
   and saved user ids after calling process invokes setresgid() to change
   the effective gid to that of specified user.
    
 
  getresuid01  
  
   Verify that getresuid() will be successful to get the real, effective
   and saved user id of the calling process.
 
  getresuid02  
  
   Verify that getresuid() will be successful to get the real, effective
   and saved user ids after calling process invokes setreuid() to change
   the effective/saved uids to that of specified user.
    
  getresuid03  
  
   Verify that getresuid() will be successful to get the real, effective
   and saved user ids after calling process invokes setresuid() to change
   the effective uid to that of specified user.
    
 
  getsid01  
  
 	getsid01 - call getsid() and make sure it succeeds
 
  getsid02  
  
 	getsid02 - call getsid() with an invalid PID to produce a failure
 
 
  getsockname01  
  
   Verify that getsockname() returns the proper errno for various failure cases

 
  getsockopt01  
  
   Verify that getsockopt() returns the proper errno for various failure cases

 
  gettimeofday01  
  
 	Testcase to check that gettimeofday(2) sets errno to EFAULT.
 
  gettimeofday02

	Testcase to check if gettimeofday is monotonous.


  getuid01

 	Basic test for getuid(2)

  getuid02  
  
 	Testcase to check the basic functionality of the geteuid() system call.

  getuid03  
  
 	Testcase to check the basic functionality of the getuid() system call.


  ioctl01  
  
 	Testcase to check the errnos set by the ioctl(2) system call.
 
  ioctl02  
  
 	Testcase to test the TCGETA, and TCSETA ioctl implementations for
 	the tty driver


  ioperm01

	Basic test for ioperm().

  ioperm02

	Test for error conditions.


  iopl01

	Basic test for iopl().

  iopl02

	Test for error conditions.

  
  ipc

	msgctl

 		msgctl01 - create a message queue, then issue the IPC_STAT command
 			   and RMID commands to test the functionality
  
	 	msgctl02 - create a message queue, then issue the IPC_SET command
 			   to lower the msg_qbytes value.
 
 		msgctl03 - create a message queue, then issue the IPC_RMID command
 	 
 		msgctl04 - test for EACCES, EFAULT and EINVAL errors using
 			   a variety of incorrect calls.
	 
 		msgctl05 - test for EPERM error

	msgget
	
 		msgget01 - create a message queue, write a message to it and
 			   read it back.
  
 		msgget02 - test for EEXIST and ENOENT errors
 
	 	msgget03 - test for an ENOSPC error by using up all available
 			   message queues.
  
	 	msgget04 - test for an EACCES error by creating a message queue
 			   with no read or write permission and then attempting
 			   to access it with various permissions.

	msgrcv
	
 		msgrcv01 - test that msgrcv() receives the expected message
  
 		msgrcv02 - test for EACCES and EFAULT errors
  
 		msgrcv03 - test for EINVAL error
 
	 	msgrcv04 - test for E2BIG and ENOMSG errors
 
	 	msgrcv05 - test for EINTR error
 
	 	msgrcv06 - test for EIDRM error

	msgsnd
	
 		msgsnd01 - test that msgsnd() enqueues a message correctly
 
	 	msgsnd02 - test for EACCES and EFAULT errors
 
	 	msgsnd03 - test for EINVAL error
 
	 	msgsnd04 - test for EAGAIN error
 
	 	msgsnd05 - test for EINTR error
 
	 	msgsnd06 - test for EIDRM error

	semctl
	
 		semctl01 - test the 10 possible semctl() commands
 
 		semctl02 - test for EACCES error
 
	 	semctl03 - test for EINVAL and EFAULT errors
 
	 	semctl04 - test for EPERM error
  
	 	semctl05 - test for ERANGE error

	semget
	
 		semget01 - test that semget() correclty creates a semaphore set
 
 		semget02 - test for EACCES and EEXIST errors
 
	 	semget03 - test for ENOENT error
 
	 	semget05 - test for ENOSPC error
 
	 	semget06 - test for EINVAL error

	semop
	
 		semop01 - test that semop() basic functionality is correct
 
 		semop02 - test for E2BIG, EACCES, EFAULT and EINVAL errors
 
 		semop03 - test for EFBIG error
 
 		semop04 - test for EAGAIN error
 
 		semop05 - test for EINTR and EIDRM errors

	shmat
	
 		shmat01 - test that shmat() works correctly
  
 		shmat02 - check for EINVAL and EACCES errors
 
	 	shmat03 - test for EACCES error

	shmctl
	
 		shmctl01 - test the IPC_STAT, IPC_SET and IPC_RMID commands as
 			   they are used with shmctl()
  
	 	shmctl02 - check for EACCES, EFAULT and EINVAL errors
 
	 	shmctl03 - check for EACCES, and EPERM errors

	shmdt

	 	shmdt01 - check that shared memory is detached correctly
  
 		shmdt02 - check for EINVAL error

	shmget
	
 		shmget01 - test that shmget() correctly creates a shared memory segment
  
 		shmget02 - check for ENOENT, EEXIST and EINVAL errors
  
	 	shmget03 - test for ENOSPC error

 		shmget04 - test for EACCES error

	 	shmget05 - test for EACCES error


  kill01  
  
 	Test case to check the basic functionality of kill().
 
  kill02

	Sending a signal to processes with the same process group ID

  kill03  
  
 	Test case to check that kill fails when given an invalid signal.
 
  kill04  
  
 	Test case to check that kill() fails when passed a non-existant pid.
 
  kill05  
  
 	Test case to check that kill() fails when passed a pid owned by another
 	user.
 
  kill06  
  
 	Test case to check the basic functionality of kill() when killing an
 	entire process group with a negative pid.
  
  kill07  
  
 	Test case to check that SIGKILL can not be caught.
 
  kill08  
  
 	Test case to check the basic functionality of kill() when kill an
 	entire process group.

  kill09

	Basic test for kill(2)

  kill10

	Signal flooding test.

  kill11

	Check that when a child is killed by its parent, it returns the
	correct values to the waiting parent--child has default values.

  kill12

	Check that when a child is killed by its parent, it returns the
	correct values to the waiting parent--the child sets signal to
	ignore the kill.
 

  lchown01  
  
   Verify that, lchown(2) succeeds to change the owner and group of a file
   specified by path to any numeric owner(uid)/group(gid) values when invoked 
   by super-user.
 
 
  lchown02  
  
    Verify that,
    1) lchown(2) returns -1 and sets errno to EPERM if the effective user id
 	of process does not match the owner of the file and the process is
 	not super user.
    2) lchown(2) returns -1 and sets errno to EACCES if search permission is
 	denied on a component of the path prefix.
    3) lchown(2) returns -1 and sets errno to EFAULT if pathname points
 	outside user's accessible address space.
    4) lchown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
 	component is too long.
    5) lchown(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname is not a directory.
    6) lchown(2) returns -1 and sets errno to ENOENT if the specified file
 	does not exists.
 

  link02

	Basic test for link(2) 

  link03

	Multi links tests

  link04

	Negative test cases for link(2)

  link05

	Multi links (EMLINK) negative test 

   
  listen01  
  
   Verify that listen() returns the proper errno for various failure cases
 

  llseek01  
  
   Verify that, llseek() call succeeds to set the file pointer position 
   to an offset larger than file size. Also, verify that any attempt
   to write to this location fails.
 
  llseek02  
  
   Verify that,
   1. llseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
      is not a proper value.
   2. llseek() returns -1 and sets errno to EBADF, if the file handle of
      the specified file is not valid.


  lseek01

	Basic test for lseek(2) 

  lseek02

	Negative test for lseek(2) 
	
  lseek03

	Negative test for lseek(2) whence

  lseek04

	Negative test for lseek(2) of a fifo 

  lseek05

	Negative test for lseek(2) of a pipe

  lseek06  
  
   Verify that, lseek() call succeeds to set the file pointer position 
   to less  than  or equal to the file size, when a file is opened for
   read or write.
 
  lseek07  
  
   Verify that, lseek() call succeeds to set the file pointer position
   to more than the file size, when a file is opened for reading/writing.
 
  lseek08  
  
   Verify that, lseek() call succeeds to set the file pointer position 
   to the end of the file when 'whence' value set to SEEK_END and any
   attempts to read from that position should fail.
 
  lseek09  
  
   Verify that, lseek() call succeeds to set the file pointer position 
   to the current specified location, when 'whence' value is set to
   SEEK_CUR and the data read from the specified location should match
   the expected data.
 
  lseek10  
  
   Verify that,
   1. lseek() returns -1 and sets errno to ESPIPE, if the file handle of
      the specified file is associated with a pipe, socket, or  FIFO.	
   2. lseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
      is not a proper value.
   3. lseek() returns -1 and sets errno to EBADF, if the file handle of
      the specified file is not valid.
 

  lstat01  
  
   Verify that, lstat(2) succeeds to get the status of a file pointed to by
   symlink and fills the stat structure elements.
 
  lstat02

	Basic test for lstat(2) 

  lstat03  
  
    Verify that,
    1) lstat(2) returns -1 and sets errno to EACCES if search permission is
       denied on a component of the path prefix.
    2) lstat(2) returns -1 and sets errno to ENOENT if the specified file
 	does not exists or empty string.
    3) lstat(2) returns -1 and sets errno to EFAULT if pathname points
 	outside user's accessible address space.
    4) lstat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
 	component is too long.
    5) lstat(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname is not a directory.


  mallopt

	Test basic functionality of mallopt().


  memcmp

	Test basic functionality of memcmp().

  
  memcpy

	Test basic functionality of memcpy().

  
  memset

	Test basic functionality of memset().

  
  mkdir01

	Basic errno test for mkdir(2) 

  mkdir02  
  
 	This test will verify that new directory created
 	by mkdir(2) inherites the group ID from the parent
       directory and S_ISGID bit, if the S_ISGID bit is set
 	in the parent directory.
 	
  mkdir03  
  
 	Check mkdir() with various error conditions that should produce
 	EFAULT, ENAMETOOLONG, EEXIST, ENOENT and ENOTDIR
 
  mkdir04  
  
	Attempt to create a directory in a directory having no permissions. 

  mkdir05  
  
 	This test will verify the mkdir(2) syscall basic functionality

  mkdir08

	Basic test for mkdir(2)


  mknod01

   Basic test for mknod(2) 

  mknod02  
  
   Verify that mknod(2) succeeds when used to create a filesystem 
   node with set group-ID bit set on a directory without set group-ID bit set.
   The node created should have set group-ID bit set and its gid should be 
   equal to that of its parent directory.
 
  mknod03  
  
   Verify that mknod(2) succeeds when used to create a filesystem 
   node with set group-ID bit set on a directory with set group-ID bit set.
   The node created should have set group-ID bit set and its gid should be 
   equal to the effective gid of the process.
 
  mknod04  
  
   Verify that mknod(2) succeeds when used to create a filesystem 
   node on a directory with set group-ID bit set.
   The node created should not have group-ID bit set and its gid should be 
   equal to the effective gid of the process.
 
  mknod05  
  
   Verify that mknod(2) succeeds when used by root to create a filesystem 
   node with set group-ID bit set on a directory with set group-ID bit set.
   The node created should have set group-ID bit set and its gid should be 
   equal to that of its parent directory.
 
  mknod06  
  
   Verify that,
    1) mknod(2) returns -1 and sets errno to EEXIST if specified path
 	already exists.
    2) mknod(2) returns -1 and sets errno to EFAULT if pathname points
 	outside user's accessible address space.
    3) mknod(2) returns -1 and sets errno to ENOENT if the directory 
 	component in pathname does not exist.
    4) mknod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
 	component was too long.
    5) mknod(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname is not a directory.
 
  mknod07  
  
   Verify that,
    1) mknod(2) returns -1 and sets errno to EPERM if the process id of
 	the caller is not super-user.
    2) mknod(2) returns -1 and sets errno to EACCES if parent directory
 	does not allow  write  permission  to  the process.

  mknod08  
  
   Verify that mknod(2) succeeds when used to create a filesystem 
   node on a directory without set group-ID bit set. The node created
   should not have set group-ID bit set and its gid should be equal to that
   of its parent directory.


  mlock01

   Test basic functionality of mlock().

  mlock02

   Test to see the proper errors are returned by mlock().


  mlockall01

   Test basic functionality of mlockall().

  mlockall02

   Test to see the proper errors are returned by mlockall().


  mmap001

   Tests mmapping a big file and writing it once 

  mmap01  
  
   Verify that, mmap() succeeds when used to map a file where size of the
   file is not a multiple of the page size, the memory area beyond the end
   of the file to the end of the page is accessible. Also, verify that
   this area is all zeroed and the modifications done to this area are
   not written to the file.

  mmap02  
  
   Call mmap() with prot parameter set to PROT_READ and with the file
   descriptor being open for read, to  map a file creating mapped memory
   with read access. The minimum file permissions should be 0444.
 
  mmap03  
  
   Call mmap() to map a file creating a mapped region with execute access
   under the following conditions -
 	- The prot parameter is set to PROT_EXE
 	- The file descriptor is open for read
 	- The file being mapped has execute permission bit set.
 	- The minimum file permissions should be 0555.
 
   The call should succeed to map the file creating mapped memory with the
   required attributes.
 
  mmap04  
  
   Call mmap() to map a file creating a mapped region with read/exec access
   under the following conditions -
 	- The prot parameter is set to PROT_READ|PROT_EXEC
 	- The file descriptor is open for read
 	- The file being mapped has read and execute permission bit set.
 	- The minimum file permissions should be 0555.
 
   The call should succeed to map the file creating mapped memory with the
   required attributes.
 
 
  mmap05  
  
   Call mmap() to map a file creating mapped memory with no access under
   the following conditions -
 	- The prot parameter is set to PROT_NONE
 	- The file descriptor is open for read(any mode other than write)
 	- The minimum file permissions should be 0444.
 
   The call should succeed to map the file creating mapped memory with the
   required attributes.
 
  mmap06  
  
   Call mmap() to map a file creating a mapped region with read access
   under the following conditions -
 	- The prot parameter is set to PROT_READ
 	- The file descriptor is open for writing.
 
   The call should fail to map the file.
 
 
  mmap07  
  
   Call mmap() to map a file creating a mapped region with read access
   under the following conditions -
 	- The prot parameter is set to PROT_WRITE
 	- The file descriptor is open for writing.
 	- The flags parameter has MAP_PRIVATE set.
 
   The call should fail to map the file.
 
  mmap08  
  
   Verify that mmap() fails to map a file creating a mapped region 
   when the file specified by file descriptor is not valid.

  mmap09

    Verify that truncating a mmaped file works correctly. 


  modify_ldt01  
  
 	Testcase to check the error conditions for modify_ldt(2)

  modify_ldt02  
  
 	Testcase to check the error conditions for modify_ldt(2)


  mount01

	Basic test for mount(2)

  mount02

	Test for checking basic error conditions  for mount(2)
 
  mount03

	Test for checking mount(2) flags

  mount04

	Test for checking EPERM

 
  mprotect01  
  
 	Testcase to check the error conditions for mprotect(2)
 
  mprotect02  
  
 	Testcase to check the mprotect(2) system call.
  
  mprotect03  
  
 	Testcase to check the mprotect(2) system call.
 
 
  mremap01  
  
   Verify that, mremap() succeeds when used to expand the existing
   virtual memory mapped region to the requested size where the
   virtual memory area was previously mapped to a file using mmap().
 
  mremap02  
  
   Verify that, 
    mremap() fails when used to expand the existing virtual memory mapped 
    region to the requested size, if the virtual memory area previously 
    mapped was not page aligned or invalid argument specified.
 
  mremap03  
  
   Verify that, 
    mremap() fails when used to expand the existing virtual memory mapped 
    region to the requested size, if there already exists mappings that
    cover the whole address space requsted or the old address specified was
    not mapped.
 
  mremap04  
  
   Verify that, 
    mremap() fails when used to expand the existing virtual memory mapped 
    region to the requested size, if the memory area cannot be expanded at
    the current virtual address and MREMAP_MAYMOVE flag not set.


  msync01  
  
   Verify that, msync() succeeds, when the region to synchronize, is part
   of, or all of a mapped region.
 
  msync02  
  
   Verify that msync() succeeds when the region to synchronize is mapped
   shared and the flags argument is MS_INVALIDATE.
 
  msync03  
  
   Verify that, msync() fails, when the region to synchronize, is outside
   the address space of the process.
 
  msync04  
  
   Verify that, msync() fails, when the region to synchronize, is mapped
   but the flags argument is invalid.
 
  msync05  
  
   Verify that, msync() fails, when the region to synchronize, was not
   mapped.
 
 
  munmap01  
  
   Verify that, munmap call will succeed to unmap a mapped file or
   anonymous shared memory region from the calling process's address space
   and after successful completion of munmap, the unmapped region is no
   longer accessible.
  
  munmap02  
  
   Verify that, munmap call will succeed to unmap a mapped file or
   anonymous shared memory region from the calling process's address space
   if the region specified by the address and the length is part or all of
   the mapped region.
 
  munmap03  
  
   Verify that, munmap call will fail to unmap a mapped file or anonymous
   shared memory region from the calling process's address space if the
   address and the length of the region to be unmapped points outside the
   calling process's address space
 
 
  nanosleep01  
  
   Verify that nanosleep() will be successful to suspend the execution
   of a process for a specified time.
 
  nanosleep02  
  
   Verify that nanosleep() will be successful to suspend the execution
   of a process, returns after the receipt of a signal and writes the
   remaining sleep time into the structure.
 
  nanosleep03  
  
   Verify that nanosleep() will fail to suspend the execution
   of a process for a specified time if interrupted by a non-blocked signal.
 
  nanosleep04  
  
   Verify that nanosleep() will fail to suspend the execution
   of a process if the specified pause time is invalid.
 

  nftw

   Basic test of nftw().

  nftw64

   Basic test of nftw64() 


  nice01  
  
   Verify that root can provide a negative value  to nice()
   and hence root can decrease the nice value of the process
   using nice() system call
 
  nice02  
  
   Verify that any user can successfully increase the nice value of
   the process by passing a higher increment value (> max. applicable limits)
   to nice() system call.
 
  nice03  
  
   Verify that any user can successfully increase the nice value of
   the process by passing an increment value (< max. applicable limits) to 
   nice() system call.
 
  nice04  
  
   Verify that, nice(2) fails when, a non-root user attempts to increase
   the priority of a process by specifying a negative increment value.
 
  nice05

   Basic test for nice(2) 
 

  open01  
  
  	Open a file with oflag = O_CREAT set, does it set the sticky bit off?
 
 	Open "/tmp" with O_DIRECTORY, does it set the S_IFDIR bit on?
 
  open02  
  
  	Test if open without O_CREAT returns -1 if a file does not exist.
 
  open03

	Basic test for open(2)  
 	
  open04  
  
 	Testcase to check that open(2) sets EMFILE if a process opens files
 	more than its descriptor size
 
  open05  
  
 	Testcase to check open(2) sets errno to EACCES correctly.
 
  open06  
  
 	Testcase to check open(2) sets errno to ENXIO correctly.
  
  open07  
  
 	Test the open(2) system call to ensure that it sets ELOOP correctly.
 
  open08  
  
 	Check for the following errors:
  	1.	EEXIST
  	2.	EISDIR
  	3.	ENOTDIR
 	4.	ENAMETOOLONG
 	5.	EFAULT
 	6.	ETXTBSY

  open09

	Does a read on a file opened with oflag set to O_WRONLY and checks for -1 return.
	Does a write on a file opened with oflag set to O_RDONLY and checks for -1 return.

  open10

	Verifies that the group ID and setgid bit are set correctly when a new file
	is created using open.


  pathconf01

	Basic test for pathconf(2) 
 	

  pause01
      Basic test for pause(2) 

  pause02  
  
   Verify that, pause() returns -1 and sets errno to EINTR after receipt
   of a signal which is caught by the calling process. Also, verify that
   the calling process will resume execution from the point of suspension.
 
  pause03  
  
   Verify that a process is no longer accessible on receipt of SIGKILL 
   signal after being suspended by pause().

 
  personality01  
  
 	personality01 - Check that we can set the personality for a process.
  
  personality02  
  
 	personality02 - Check that we get EINVAL for a bad personality.
 

  pipe01  
  
 	Testcase to check the basic functionality of the pipe(2) syscall:
 	Check that both ends of the pipe (both file descriptors) are
 	available to a process opening the pipe.
 
  pipe05  
  
 	Check what happens when pipe is passed a bad file descriptor.
 
  pipe06  
  
 	Check what happens when the system runs out of pipes.
 
  pipe08  
  
 	Check that a SIGPIPE signal is generated when a write is
 	attempted on an empty pipe.
 
  pipe09  
  
 	Check that two processes can use the same pipe at the same time.
  
  pipe10  
  
 	Check that parent can open a pipe and have a child read from it
 
  pipe11  
  
 	Check if many children can read what is written to a pipe by the
 	parent.
 

  poll01  
  
   Verify that valid open file descriptor must be provided to poll() to
   succeed.
 
 
  prctl01

   Basic test of prctl().

  prctl02

   Test of error conditions for prctl().


  pread01  
  
   Verify the functionality of pread() by writing known data using pwrite()
   to the file at various specified offsets and later read from the file from
   various specified offsets, comparing the data read aganist the data 
   written.
 
  pread02  
  
   Verify that,
    1) pread() fails when attempted to read from an unnamed pipe.
    2) pread() fails if the specified offset position was invalid.


  profil01

   Basic test of profil().
 
 
  ptrace01

	 Functionality test for ptrace(2).

  ptrace02

 	 Functionality test for ptrace(2).

  ptrace3

 	Tests for error conditions.


  pwrite01  
  
   Verify the functionality of pwrite() by writing known data using pwrite()
   to the file at various specified offsets and later read from the file from
   various specified offsets, comparing the data written aganist the data
   read using read().
  
  pwrite02  
  
   Verify that,
    1) pwrite() fails when attempted to write to an unnamed pipe.
    2) pwrite() fails if the specified offset position was invalid.
 
 
  read01

	Basic test for the read(2) system call
 
  read02  
  
  	test 1:
 	Does read return -1 if file descriptor is not valid, check for EBADF
 
 	test 2:
 	Check if read sets EISDIR, if the fd refers to a directory
 
  	test 3:
  	Check if read sets EFAULT, if buf is -1.
  	  	
  read03  
  
 	Testcase to check that read() sets errno to EAGAIN

  read04  
  
 	Testcase to check if read returns the number of bytes read correctly.
 

  readdir01

	Write multiple files and try to find them with readdir().

  readdir02

	Try to readdir with invalid directory stream descriptor dir.


  readlink01  
  
   Verify that, readlink will succeed to read the contents of the symbolic
   link created the process.

  readlink02

   Basic test for the readlink(2) system call 

  readlink03  
  
    Verify that,
    1) readlink(2) returns -1 and sets errno to EACCES if search/write
 	permission is denied in the directory where the symbolic link
 	resides.
    2) readlink(2) returns -1 and sets errno to EINVAL if the buffer size
 	is not positive.
    3) readlink(2) returns -1 and sets errno to EINVAL if the specified
 	file is not a symbolic link file.
    4) readlink(2) returns -1 and sets errno to ENAMETOOLONG if the 
 	pathname component of symbolic link is too long (ie, > PATH_MAX).
    5) readlink(2) returns -1 and sets errno to ENOENT if the component of
 	symbolic link points to an empty string.
 
  readlink04  
  
   Verify that, readlink call will succeed to read the contents of the
   symbolic link if invoked by non-root user who is not the owner of the
   symbolic link.


  readv01  
  
 	Testcase to check the basic functionality of the readv(2) system call.
 
  readv02  
  
 	Testcase to check the error conditions of the readv(2) system call.


  reboot01

	Test basic functionality of reboot().

  reboot02

	Test error conditions of reboot().
 

  recv01  
  
   Verify that recv() returns the proper errno for various failure cases

 
  recvfrom01  
  
   Verify that recvfrom() returns the proper errno for various failure cases

 
  recvmsg01  
  
   Verify that recvmsg() returns the proper errno for various failure cases

 
  rename01  
  
 	This test will verify the rename(2) syscall basic functionality.
 	Verify rename() works when the "new" file or directory does not exist.
 
  rename02

	Basic test for the rename(2) system call

  rename03  
  
 	This test will verify that rename(2) functions correctly
 	when the "new" file or directory exists
 
  rename04  
  
 	This test will verify that rename(2) failed when newpath is 
       a non-empty directory and return EEXIST or ENOTEMPTY
 
  rename05  
  
 	This test will verify that rename(2) fails with EISDIR
 
  rename06  
  
 	This test will verify that rename(2) failed in EINVAL
 
  rename07  
  
 	This test will verify that rename(2) failed in ENOTDIR
 
  rename08  
  
 	This test will verify that rename(2) syscall failed in EFAULT
 
  rename09  
  
       check rename() fails with EACCES
 
  rename10  
  
 	This test will verify that rename(2) syscall fails with ENAMETOOLONG
       and ENOENT
 
  rename11  
  
 	This test will verify that rename(2) failed in EBUSY
 
  rename12  
  
       check rename() fails with EPERM
 
  rename13  
  
       Verify rename() return successfully and performs no other action
       when "old" file and "new" file link to the same file.
  


  rmdir01  
  
 	This test will verify that rmdir(2) syscall basic functionality.
 	verify rmdir(2) returns a value of 0 and the directory being
 	removed 
 
  rmdir02  
  
 	This test will verify that rmdir(2) fail in 
       1. ENOTEMPTY
       2. EBUSY
       3. ENAMETOOLONG
       4. ENOENT
       5. ENOTDIR
       6. EFAULT
       7. EFAULT
  
  rmdir03  
  
       check rmdir() fails with EPERM or EACCES
 
  rmdir04

	Basic test for the rmdir(2) system call 

  rmdir05

	Verify that rmdir(2) returns a value of -1 and sets errno to indicate the error.
 

  sbrk01

	Basic test for the sbrk(2) system call. 


  sched_get_priority_max01

	Basic test for sched_get_priority_max().

  sched_get_priority_max02

	Error condition test for sched_get_priority_max().


  sched_get_priority_min01

	Basic test for sched_get_priority_min().

  sched_get_priority_min02

	Error condition test for sched_get_priority_min().


  sched_getparam01

	 Basic test for sched_getparam(2)

  sched_getparam02

 	 Get scheduling parametes for parent process
	 
  sched_getparam03

 	 Testing error conditions for sched_getparam(2)


  sched_getscheduler01  
  
 	Testcase to check sched_getscheduler() returns correct return value 
 
  sched_getscheduler02  
  
 	To check for the errno ESRCH
 

  sched_rr_get_interval01

 	Basic test for sched_rr_get_interval(2)

  sched_rr_get_interval02

 	Functionality test

  sched_rr_get_interval03
  
	Tests for error conditions


  sched_setparam01

	Basic test for sched_setparam(2)

  sched_setparam02

 	Checks functionality for sched_setparam(2)

  sched_setparam03

 	Checks functionality for sched_setparam(2) for pid!=0

  sched_setparam04

 	Testing error conditions for sched_setparam(2)

  sched_setparam05

 	Verify that sched_setparam() fails if the user does


  sched_setscheduler01  
  
 	Testcase to test whether sched_setscheduler(2) sets the errnos
 	correctly.
 
  sched_setscheduler02  
  
 	Testcase to test whether sched_setscheduler(2) sets the errnos
 	correctly.
 
 
  sched_yield01  
  
 	Testcase to check that sched_yield returns correct values.
 

  select01

	Basic test for the select(2) system call to a fd of regular file with no I/O 
	and small timeout 

  select02

	Basic test for the select(2) system call to fd of system pipe with no I/O 
	and small timeout 
  
  select03

	Basic test for the select(2) system call to fd of a named-pipe (FIFO) 

  select04  
  
   Verify that select(2) returns immediately (does not block) if the
   timeout value is zero.
 
  select05  
  
   Verify that select(2) fails when one or more of the file descriptor sets
   specify a file descriptor which is not valid.
 
  select06  
  
   Verify that select(2) fails when a signal is delivered before any of the
   selected events occur and before the timeout interval expires.
 
  select07  
  
   Verify that select(2) fails when an invalid timeout interval is specified.
 
  select08  
  
   Verify the functionality of select(2) by passing non-null writefds
   which points to a regular file, pipes or FIFO's.
  
  select09  
  
   Verify the functionality of select(2) by passing non-null readfds
   which points to a regular file, pipes or FIFO's.

  select10 
  
   Verify that a successful call to select() shall return the desired 
   number of modified descriptors for which bits are set in the bit masks, 
   where descriptors points to a regular file, pipes or FIFO's.
 

  send01  
  
   Verify that send() returns the proper errno for various failure cases

 
  sendfile02  
  
 	Testcase to test the basic functionality of the sendfile(2) system call.
 
  sendfile03  
  
 	Testcase to test that sendfile(2) system call returns appropriete
 	errnos on error.


  sendmsg01  
  
   Verify that sendmsg() returns the proper errno for various failure cases

 
  sendto01  
  
   Verify that sendto() returns the proper errno for various failure cases


  setdomainname01

	 Basic test for setdomainame(2)

  setdomainname02

 	Test for checking error conditions for setdomainame(2)

  setdomainname03

	Test for EPERM error value when run as non superuser


  setegid01

	Verify that setegid does not modify the saved gid or real gid.


  setfsgid01  
  
 	Testcase to check the basic functionality of setfsgid(2) system
 	call.

 
  setfsuid01  
  
 	Testcase to test the basic functionality of the setfsuid(2) system
 	call.
 

  setgid01

	Basic test for the setgid(2) system call. 

  setgid02
  
  	Testcase to ensure that the setgid() system call sets errno to EPERM
 
  
  setgroups01

	Basic test for the setgroups(2) system call. 
  
  setgroups02  
  
   Verify that,
    1. setgroups() fails with -1 and sets errno to EINVAL if the size
       argument value is > NGROUPS
    2. setgroups() fails with -1 and sets errno to EPERM if the
 	calling process is not super-user.
  
  setgroups03  
  
   Verify that, only root process can invoke setgroups() system call to
   set the supplementary group IDs of the process.
   

  setitimer01  
  
 	setitimer01 - check that a resonable setitimer() call succeeds.
 
  setitimer02  
  
 	setitimer02 - check that a setitimer() call fails as expected
 		      with incorrect values.
 
  setitimer03  
  
 	setitimer03 - check that a setitimer() call fails as expected
 		      with incorrect values.
 
  setpgid01	 	

	Basic test for setpgid(2) system call. 

  setpgid02  
  
 	Testcase to check that setpgid() sets errno correctly.
 
  setpgid03  
  
  	Test to check the error and trivial conditions in setpgid system call


  setpgrp01

	Basic test for the setpgrp(2) system call.  

  setpgrp02  
  
 	Testcase to check the basic functionality of the setpgrp(2) syscall.
 

  setpriority01  
  
 	setpriority01 - set the priority for the test process lower.
 
  setpriority02  
  
 	setpriority02 - test for an expected failure by trying to raise
 			the priority for the test process while not having
 			permissions to do so.
 
  setpriority03  
  
 	setpriority03 - test for an expected failure by using an invalid
 			PRIO value
  setpriority04  
  
 	setpriority04 - test for an expected failure by using an invalid
 			process id
 
  setpriority05  
  
 	setpriority05 - test for an expected failure by trying to change
 			a process with an ID that is different from the
 			test process

  setregid01	 

	Basic test for the setregid(2) system call. 
 
  setregid02  
  
  	Test that setregid() fails and sets the proper errno values when a
 	non-root user attemps to change the real or effective group id to a 
 	value other than the current gid or the current effective gid. 
 
  setregid03  
  
  	Test setregid() when executed by a non-root user.
 
  setregid04  
  	
  	Test setregid() when executed by root.

  
  setresgid01

	Checks functionality of setresgid(2)

  setresgid02

 	Checks functionality of setresgid(2) for non-root group id.

  setresgid03

	Checks error conditions for setresgid(2)

 
  setresuid01  
  
  	Test setresuid() when executed by root.
 
  setresuid02  
  
  	Test that a non-root user can change the real, effective and saved
 	uid values through the setresuid system call.
 
  setresuid03  
  
  	Test that the setresuid system call sets the proper errno
 	values when a non-root user attempts to change the real, effective or
 	saved uid to a value other than one of the current uid, the current
 	effective uid of the current saved uid.  Also verify that setresuid
 	fails if an invalid uid value is given.

 
  setreuid01	 	

	Basic test for the setreuid(2) system call. 

  setreuid02  
  
  	Test setreuid() when executed by root.
 
  setreuid03  
  
  	Test setreuid() when executed by an unpriviledged user.
 
  setreuid04  
  
  	Test that root can change the real and effective uid to an
 	unpriviledged user.
 
  setreuid05  
  
  	Test the setreuid() feature, verifying the role of the saved-set-uid
  	and setreuid's effect on it.
 
  setreuid06  
  
  	Test that EINVAL is set when setreuid is given an invalid user id.


  setrlimit01  
  
 	Testcase to check the basic functionality of the setrlimit system call.
 
  setrlimit02  
  
 	Testcase to test the different errnos set by setrlimit(2) system call.
 
  setrlimit03  
  
 	Test for EPERM when the super-user tries to increase RLIMIT_NOFILE
 	beyond the system limit.

 
  setsid01  
  
  	Test to check the error and trivial conditions in setsid system call

 
  setsockopt01  
  
   Verify that setsockopt() returns the proper errno for various failure cases

 
  settimeofday01  
  
 	Testcase to check the basic functionality of settimeofday().
 
  settimeofday02  
  
 	Testcase to check that settimeofday() sets errnos correctly.

 
  setuid01

 	Basic test for the setuid(2) system call. 

  setuid02

	Basic test for the setuid(2) system call as root. 

  setuid03  
  
  	Test to check the error and trivial conditions in setuid
 

  sigaction01  
  
  	Test some features of sigaction (see below for more details)

 
  sigaction02  
  
  	Testcase to check the basic errnos set by the sigaction(2) syscall.
 
 
  sigaltstack01  
  
   Send a signal using the main stack. While executing the signal handler
   compare a variable's address lying on the main stack with the stack
   boundaries returned by sigaltstack().
 
  sigaltstack02  
  
   Verify that,
    1. sigaltstack() fails and sets errno to EINVAL when "ss_flags" field
       pointed to by 'ss' contains invalid flags.
    2. sigaltstack() fails and sets errno to ENOMEM when the size of alternate
       stack area is less than MINSIGSTKSZ.


  sighold02

	Basic test for the sighold02(2) system call. 

 
  signal01  
  
 	signal01 - set the signal handler to our own function
 
  signal02  
  
 	signal02 - Test that we get an error using illegal signals

  signal03

	Boundary value and other invalid value checking of signal setup and signal 
	sending. 
  
  signal04  
  
 	signal04 - restore signals to default behavior
 
  signal05  
  
 	signal03 - set signals to be ignored


  sigpending02

	Test to see that the proper errors are returned by sigpending.


  sigprocmask01  
  
   Verify that sigprocmask() succeeds to examine and change the calling
   process's signal mask. 
   Also, verify that sigpending() succeeds to store signal mask that are
   blocked from delivery and pending for the calling process.


  sigrelse01

	Basic test for the sigrelse(2) system call. 


  sigsuspend01  
  
   Verify that sigsuspend() succeeds to change process's current signal
   mask with the specified signal mask and suspends the process execution
   until the delivery of a signal.
 
 
  socket01  
  
   Verify that socket() returns the proper errno for various failure cases


  socketcall01

	Basic test for socketcall(2) for socket(2)

  socketcall02

 	Error test for socketcall(2)

  socketcall03

 	Basic test for socketcall(2) for bind(2)

  socketcall04

 	Basic test for socketcall(2) for listen(2)


  socketpair01

	Verify that socketpair() returns the proper errno for various
	failure cases  

 
  socketpair01  
  
   Verify that socketpair() returns the proper errno for various failure cases

 
  sockioctl01  
  
   Verify that ioctl() on sockets returns the proper errno for various
   failure cases
 

  stat01  
  
   Verify that, stat(2) succeeds to get the status of a file and fills the
   stat structure elements.
 
  stat02  
  
   Verify that, stat(2) succeeds to get the status of a file and fills the
   stat structure elements though process doesn't have read access to the
   file.
 
  stat03  
  
    Verify that,
    1) stat(2) returns -1 and sets errno to EACCES if search permission is
       denied on a component of the path prefix.
    2) stat(2) returns -1 and sets errno to ENOENT if the specified file
 	does not exists or empty string.
    3) stat(2) returns -1 and sets errno to EFAULT if pathname points
 	outside user's accessible address space.
    4) stat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
 	component is too long.
    5) stat(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname is not a directory.
 
  stat05

	Basic test for the stat05(2) system call. 


  statfs01

 	Basic test for the statfs(2) system call. 

  statfs02  
  
 	Testcase to check that statfs(2) sets errno correctly.


  stime01  
  
   Verify that the system call stime() successfully sets the system's idea
   of data and time if invoked by "root" user.
 
  stime02  
  
    Verify that the system call stime() fails to set the system's idea
    of data and time if invoked by "non-root" user.


  string01

	Test string functions.


  swapoff01

	 Basic test for swapoff(2)

  swapoff02

	 Test checking for basic error conditions

 
  swapon01

	 Basic test for swapon(2)

  swapon02

	 Test checking for basic error conditions

 
  symlink01

	Test of various file function calls, such as rename or open, on a symbolic 
	link file. 

  symlink02

	Basic test for the symlink(2) system call. 

  symlink03  
  
    Verify that,
    1) symlink(2) returns -1 and sets errno to EACCES if search/write
 	permission is denied in the directory where the symbolic link is
 	being created.
    2) symlink(2) returns -1 and sets errno to EEXIST if the specified 
 	symbolic link already exists.
    3) symlink(2) returns -1 and sets errno to EFAULT if the specified
 	file or symbolic link points to invalid address.
    4) symlink(2) returns -1 and sets errno to ENAMETOOLONG if the 
 	pathname component of symbolic link is too long (ie, > PATH_MAX).
    5) symlink(2) returns -1 and sets errno to ENOTDIR if the directory
 	component in pathname of symbolic link is not a directory.
    6) symlink(2) returns -1 and sets errno to ENOENT if the component of
 	symbolic link points to an empty string.

  symlink04  
  
   Verify that, symlink will succeed to creat a symbolic link of an existing
   object name path.
 
  symlink05  
  
   Verify that, symlink will succeed to creat a symbolic link of an
   non-existing object name path.

   
  sync01

    Basic test for the sync(2) system call. 

  sync02  
  
   Open a file for write; modify the file, then do a sync().
   Verify that the data has been written to disk by re-opening the file.
 

  syscall01

   Basic test for the syscall() system call.
 

  sysconf01

   Basic test for the sysconf() system call.
 

  sysctl01  
  
 	Testcase for testing the basic functionality of sysctl(2) system call.
 	This testcase attempts to read the kernel parameters using
 	sysctl({CTL_KERN, KERN_ }, ...) and compares it with the known
 	values.
 
  sysctl03  
  
 	Testcase to check that sysctl(2) sets errno to EPERM correctly.
 
 
  sysctl04  
  
 	Testcase to check that sysctl(2) sets errno to ENOTDIR
 
 
  sysctl05  
  
 	Testcase to check that sysctl(2) sets errno to EFAULT
 

  sysfs01

	Basic test for sysfs(2)

  sysfs02

	Basic test for sysfs(2)

  sysfs03

	Basic test for sysfs(2)

  sysfs04

 	Test checking for basic error conditions

  sysfs05

 	Test checking for basic error conditions

  sysfs06

 	Test checking for basic error conditions


  sysinfo01

	Verify that sysinfo() succeeds to get the system information and fills
	the structure passed.

  sysinfo02

	Verify that sysinfo() returns the correct error for an invalid address structure.

  syslog01

 	Test whether messages are logged to the specified file  

  syslog02

 	Test if messages of all levels are logged.              

  syslog03

 	Do openlog(), log the messages and see whether         
 	ident string is prepended to the message.

  syslog04

	Test the logging option: LOG_PID                        

  syslog05
	
	Test the logging option: LOG_CONS                       

  syslog06

 	Test the logging option: LOG_NDELAY                    

  syslog07
 
	Test the priorities.                                

  syslog08
 
	Test all the facilities at a particular level.         

  syslog09
 
	Test setlogmask() with LOG_UPTO macro.                 

  syslog10
 
	Test setlogmask() with LOG_MASK macro.                

  syslog11

	Basic test for syslog() function call.

  syslog12
	
	Check error conditions for syscall().
	

  time01

	Basic test for the time(2) system call. 

  time02  
  
   Verify that time(2) returns the value of time in seconds since
   the Epoch and stores this value in the memory pointed to by the parameter.

 	
  times01

	Basic test for the times(2) system call. 
 
  times03  
  
 	Testcase to check the basic functionality of the times() system call.
 

  truncate01  
  
   Verify that, truncate(2) succeeds to truncate a file to a specified
   length.
 
  truncate02  
  
   Verify that, truncate(2) succeeds to truncate a file to a certain length,
   but the attempt to read past the truncated length will fail.  
 
  truncate03  
  
   Verify that,
   1) truncate(2) returns -1 and sets errno to EACCES if search/write
      permission denied for the process on the component of the path prefix
      or named file.
   2) truncate(2) returns -1 and sets errno to ENOTDIR if the component of
      the path prefix is not a directory.
   3) truncate(2) returns -1 and sets errno to EFAULT if pathname points
      outside user's accessible address space.
   4) truncate(2) returns -1 and sets errno to ENAMETOOLONG if the component
      of a pathname exceeded 255 characters or entire pathname exceeds 1023
      characters.
   5) truncate(2) returns -1 and sets errno to ENOENT if the named file
      does not exist.


  ulimit01

	Basic test for the ulimit(2) system call. 


  umask01

	Basic test for the umask(2) system call. 

  umask02  
  
 	Check that umask changes the mask, and that the previous
 	value of the mask is returned correctly for each value.
 
  umask03  
  
 	Check that umask changes the mask, and that the previous
 	value of the mask is returned correctly for each value.


  umount01

	Basic test for umount(2)

  umount02

	 Test for checking basic error conditions for umount(2)

  umount03

	 Test for checking EPERM

  umount04

	Test for checking EACCES


  uname01

	Basic test for the uname(2) system call.  

  uname02  
  
 	Call uname() with an invalid address to produce a failure
 
  uname03  
  
 	Call uname() and make sure it succeeds


 
  unlink05

	Basic test for the unlink(2) system call. 

  unlink06

 	Test for the unlink(2) system call of a FIFO. 

  unlink07

 	Tests for error handling for the unlink(2) system call. 

  unlink08

 	More tests for error handling for the unlink(2) system call.


  ustat01

	Basic test for the ustat() system call.

  ustat02

	Test for error conditions of ustat().


  utime01  
  
   Verify that the system call utime() successfully sets the modification
   and access times of a file to the current time, if the times argument
   is null, and the user ID of the process is "root".
 
  utime02  
  
   Verify that the system call utime() successfully sets the modification
   and access times of a file to the current time, under the following
   constraints,
 	- The times argument is null.
 	- The user ID of the process is not "root".
 	- The file is owned by the user ID of the process.
 
  utime03  
  
   Verify that the system call utime() successfully sets the modification
   and access times of a file to the current time, under the following
   constraints,
 	- The times argument is null.
 	- The user ID of the process is not "root".
 	- The file is not owned by the user ID of the process.
 	- The user ID of the process has write access to the file.
 
  utime04  
  
   Verify that the system call utime() successfully sets the modification
   and access times of a file to the time specified by times argument, if
   the times argument is not null, and the user ID of the process is "root".
 
  utime05  
  
   Verify that the system call utime() successfully sets the modification
   and access times of a file to the value specified by the times argument
   under the following constraints,
 		- The times argument is not null,
 		- The user ID of the process is not "root".
 		- The file is owned by the user ID of the process.
 
  utime06  
  
  1. Verify that the system call utime() fails to set the modification
     and access times of a file to the current time, under the following
     constraints,
 	 - The times argument is null.
 	 - The user ID of the process is not "root".
 	 - The file is not owned by the user ID of the process.
 	 - The user ID of the process does not have write access to the
 	   file.
  2. Verify that the system call utime() fails to set the modification
     and access times of a file if the specified file doesn't exist.

 
  vfork01  
  
   Fork a process using vfork() and verify that, the attribute values like
   euid, ruid, suid, egid, rgid, sgid, umask, inode and device number of
   root and current working directories are same as that of the parent 
   process.
    
  vfork02  
  
   Fork a process using vfork() and verify that, the pending signals in
   the parent are not pending in the child process.
  
  
  vhangup01  
  
 	Check the return value, and errno of vhangup(2)
 	when a non-root user calls vhangup().
 
  vhangup02  
  
  	To test the basic functionality of vhangup(2)

 
  wait02

	Basic test for wait(2) system call. 

 
  wait401  
  
 	wait401 - check that a call to wait4() correctly waits for a child
 		  process to exit
 
  wait402  
  
 	wait402 - check for ECHILD errno when using an illegal pid value

 
  waitpid01  
  
 	Check that when a child kills itself by generating an alarm
 	exception, the waiting parent is correctly notified.
 
  waitpid02  
  
 	Check that when a child kills itself by generating an integer zero
 	divide exception, the waiting parent is correctly notified.
 
  waitpid03  
  
 	Check that parent waits unitl specific child has returned.
 
  waitpid04  
  
 	test to check the error conditions in waitpid sys call
 
  waitpid05  
  
 	Check that when a child kills itself with a kill statement after
 	determining its process id by using getpid, the parent receives a
 	correct report of the cause of its death. This also indirectly
 	checks that getpid returns the correct process id.
 
  waitpid06  
  
 	Tests to see if pid's returned from fork and waitpid are same.
 
  waitpid07  
  
 	Tests to see if pid's returned from fork and waitpid are same.
 
  waitpid08  
  
 	Tests to see if pid's returned from fork and waitpid are same
 	
  waitpid09  
  
 	Check ability of parent to wait until child returns, and that the
 	child's process id is returned through the waitpid. Check that
 	waitpid returns immediately if no child is present.
 	
  waitpid10  
  
  	Tests to see if pid's returned from fork and waitpid are same
 
 
  waitpid11  
  
 	Tests to see if pid's returned from fork and waitpid are same
 	
 
  waitpid12  
  
 	Tests to see if pid's returned from fork and waitpid are same
 	
 
  waitpid13  
  
 	Tests to see if pid's returned from fork and waitpid are same

 	
  write01

	Basic test for write(2) system call.
 
  write02  
  
 	Basic functionality test: does the return from write match the count
 	of the number of bytes written.
 
  write03  
  
 	Testcase to check that write(2) doesn't corrupt a file when it fails
 
  write04  
  
 	Testcase to check that write() sets errno to EAGAIN

  write05  
  
 	Check the return value, and errnos of write(2)
  	- when the file descriptor is invalid - EBADF
 	- when the buf parameter is invalid - EFAULT
 	- on an attempt to write to a pipe that is not open for reading - EPIPE

 
  writev01  
  
 	Testcase to check the basic functionality of writev(2) system call.
 
  writev02  
  
 	In these testcases, writev() is called with partially valid data 
 	to be written in a sparse file.
 
 
  writev03  
  
 	The testcases are written calling writev() with partially valid data
 	to overwrite the contents, to write in the beginning and to write in
 	the end of the file.
 
  writev04  
  
 	The testcases are written calling writev() with partially valid data
 	to overwrite the contents, to write in the beginning and to write in
 	the end of the file. This is same as writev03, but the length of
 	buffer used here is 8192 bytes.
 
  writev05  
  
 	These testcases are written to test writev() on sparse files. This
 	is same as writev02. But the initial write() with valid data is
 	done at the beginning of the file.
 

  
timers
------ 
  clock_gettime02

	Basic test for clock_gettime(2)
  
  clock_gettime03

 	Test checking for basic error conditions for clock_gettime(2)


  clock_settime02

	Basic test for clock_settime(2)
  
  clock_settime03

 	Test checking for basic error conditions for clock_settime(2)

  
  timer_create01

	Basic test for timer_create(2)
  
  timer_create02

	Basic test for timer_create(2)
  
  timer_create03

 	Test checking for basic error conditions for timer_create(2)


  timer_delete01

	Basic test for timer_delete(2)
  
  timer_delete02

 	Test checking for basic error conditions for timer_delete(2)


  timer_settime01

	Basic test for timer_settime(2)
  
  timer_settime02

 	Test checking for basic error conditions for timer_settime(2)


